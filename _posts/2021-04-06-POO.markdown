---
layout: post
title: "POO"
subtitle: 'POO'
date: 2021-04-02 12:00:00
author: "TheusZero"
header-img: "images/post/PythonAutoayuda/solarized-wallpaper-python.png"
catalog: true
comments: true
tags:
    - Programacion
    - Python
    - USM
    - Tareas
    - Java
    - C++
---

## Programacion en java codigo

[Curso Java Intermedio - La Geekipedia De Ernesto](https://www.youtube.com/watch?v=TjrPp48_ms0&list=PLyvsggKtwbLXEZjb8HrNTbWesTKIfpNak)

[Curso Java - Programacion ATS](https://www.youtube.com/watch?v=2ZXiuh0rg3M&list=PLWtYZ2ejMVJkjOuTCzIk61j7XKfpIR74K)

#### constantes final y static

Se usa la palabra reservada final, este atributo no sera cambiado nunca

Ej: public final float CM_PER_INCH=2.54;

> Si deseamos crear sólo una instancia de esta constante para todos los objetos de una clase, usamos:

static lo que hace es fijar un contenido en memoria reservado para la variable. con final, su valor no cambiara nunca y siempre podremos acceder a la variable static, static nos deja acceder siempre a la variable
static tambien se ejecuta antes de cualquiera instruccion del main
![](/TheusZero/images/post/POO/63.png)


```java
public class Constante {
public static final float CM_PER_INCH=2.54;
...}
```

**Para acceder al valor: Constante.CM_PER_INCH**

#### arrays Unidimensionales

Los arreglos almacenan una colección de valores de igual tipo, su
acceso es vía un índice entero (0<= índice < max)

> Declaración de una variable arreglo de enteros:
> 
>> ```int [] a;``` // hasta aquí sólo tenemos en identificador
> 
>> ```a = new int[100];``` //recién ahora tenemos los datos

> ![](/TheusZero/images/post/POO/61.png)
> ![](/TheusZero/images/post/POO/62.png)

> ![](/TheusZero/images/post/POO/6.png)
> ![](/TheusZero/images/post/POO/7.png)
> ![](/TheusZero/images/post/POO/8.png)

#### arrays bidimensionales o de muchas dimensiones
> ![](/TheusZero/images/post/POO/10.png)
> ![](/TheusZero/images/post/POO/11.png)
> ![](/TheusZero/images/post/POO/12.png)

#### for each
> ![](/TheusZero/images/post/POO/9.png)

## Clases, objetos y comportamiento

> ![](/TheusZero/images/post/POO/13.png)

> Clases, forma generalizada (idea) para hablar de objetos ya que estas definen las caracterizticas generales de una clase objeto.
>> objeto Patricio, clase Persona

Estas clases tienen **atributos** que son generales (RUT, EDAD, etc) y tambien tenemos comportamientos llamados **metodos**, (caminar, comer, respirar, etc).
Estos estaran definidos desde la clase.

> por lo que, las clases son un conjunto de objetos con caracteristicas similares
> ![](/TheusZero/images/post/POO/14.png)

> Clase: es la definición de las características comunes a un conjunto de objetos. Las característica comunes son los atributos a considerar y el comportamiento de esos objetos.

> Objeto: en POO un objeto es la representación en un programa de un objeto real. Esta representación define un nombre, un estado y un comportamiento para el objeto. Un objeto es una instancia de una Clase.

> Atributo: es una un dato que permite almacenar parte del estado de un objeto. El conjunto de atributos de un objeto almacenan su estado.

> Constructor: Código que define el valor inicial de un objeto al ser creado.

#### creacion de clases y objetos

> ![](/TheusZero/images/post/POO/15.png)

> ![](/TheusZero/images/post/POO/16.png)

> ![](/TheusZero/images/post/POO/17.png)

> ![](/TheusZero/images/post/POO/18.png)

> ![](/TheusZero/images/post/POO/19.png)

> ![](/TheusZero/images/post/POO/20.png)

> ![](/TheusZero/images/post/POO/64.png)

> ![](/TheusZero/images/post/POO/65.png)


#### Constructores

> Inicializa objetos nuevos siguiendo el siguiente orden:
> 
> 1. Localiza memoria
> 
> 2. Asigna valores a atributos (0, 0.0, null, …)
> 
> 3. Según el orden de aparición de los atributos de la clase se ejecutan las inicializaciones allí hechas
> 
> 4. Llama constructor de Superclase (o clase padre).
> 
> 5. Se ejecutan las sentencias del constructor.

> La primera sentencia puede ser:
>>```super( … )``` para llamar a un constructor de la clase base (o padre o superclase)
> 
>>```this( … )``` para invocar a otro constructor de la misma clase


> ![](/TheusZero/images/post/POO/21.png)
>> O bien tambien puede quedar: 
>> ![](/TheusZero/images/post/POO/22.png)
> ![](/TheusZero/images/post/POO/23.png)

#### Miembros estáticos de una clase

> si se antepone static, la variable pasa a ser para toda la clase, es decir, que si hacemos un cambio, este repercute y cambia todas las variables, por ejemplo
>> ![](/TheusZero/images/post/POO/26.png)

> ademas para la creacion de clase, esto pasa:
>> ![](/TheusZero/images/post/POO/27.png)

#### metodos getter/setter

> ![](/TheusZero/images/post/POO/24.png)

#### Jerarquias de Clases: Herencia

> la clase estudiante y profesor heredan de la clase persona atributos, por lo que hay una jerarquia que define a persona como un general del cual heredan atributos otras clases
> ![](/TheusZero/images/post/POO/2.png)
> ![](/TheusZero/images/post/POO/3.png)
> ![](/TheusZero/images/post/POO/4.png)
> ![](/TheusZero/images/post/POO/5.png)

#### clases y metodos abstractos:

> Clase abstracta
>> Se utilizan solo como super clases (clases padres)
>
>> No se pueden instanciar objetos, no puedes crear objetos
>
>> Sirve para proporcionar una clase padre apropiada a partir de la cual heredan otras clases, siendo estas otras clases hijas las que extenderan el funcionamiento de los metodos, es decir, que seran quienes expliquen el funcionamiento en base a codigo. La clase Padre solo dice que el metodo existe, pero no como es que sera llevado a cabo.
>
>> ![](/TheusZero/images/post/POO/30.png)
>> ![](/TheusZero/images/post/POO/31.png)
>> ![](/TheusZero/images/post/POO/32.png)
>> ![](/TheusZero/images/post/POO/33.png)
>> ![](/TheusZero/images/post/POO/34.png)
>> ![](/TheusZero/images/post/POO/35.png)
>> ![](/TheusZero/images/post/POO/36.png)




#### herencias

La idea básica es poder crear clases basadas en clases ya
existentes.

Cuando heredamos de una clase existente, estamos
reutilizando código (métodos y atributos de la clase base).

Agregar métodos y atributos para adaptar la clase heredada a
las particularidades de la nueva categoría de objetos.

Java también permite consultar por la estructura de una clase
(cuáles son sus métodos y atributos). A esto se le llama
reflexión. ¿Sabrán los animales que son animales?

Identificamos herencia cuando encontramos la relación **es-un**
entre una clase nueva y una ya existente. Ej.: un estudiante es
una persona

La relación es-un es una condición necesaria pero no
suficiente, además los objetos de la clase heredada deben
cumplir el principio de sustitución.

Se cumple el principio de sustitución cuando un objeto de la
clase derivada puede responder de buena forma a todos los
métodos públicos de la clase base

La clase ya existente se le llama superclase, clase base, o
clase padre (son sinónimos aquí).
A la clase nueva se le llama subclase, clase derivada, o clase
hija.

![](/TheusZero/images/post/POO/67.png)

> Aspectos sintácticos en Java
> 
> Si un mánager es un empleado y cumple el principio de sustitución, entonces podemos definir Manager extendiendo la clase Empleado:
> ![](/TheusZero/images/post/POO/68.png)


> Redefinición de métodos
> En la clase derivada podemos redefinir (override, o sobremontar) métodos, lo cual corresponde a re-implementar o recodificar en la subclase un método de la clase base.
>
> Si en la clase hija deseamos acceder al método de la clase base, lo podemos hacer utilizando la palabra super como referencia al padre.
>
> Recordar que también usamos esta palabra reservada para invocar constructores de la clase base.
> ![](/TheusZero/images/post/POO/69.png)

#### principio de sustitucion

Según el principio de sustitución, referencias a objetos
de la clase base, pueden apuntar a objetos de una
clase derivada sin crear problemas.

Hay que tener cuidado con la relación es-un. El
castellano permite decir que un cuadrado es un
rectángulo de lados iguales; sin embargo, esto lleva a
problemas cuando queremos aplicar el principio de
sustitución.

> Ejemplo: ¿Los cuadrados son rectángulos?
> ![](/TheusZero/images/post/POO/70.png)
> ![](/TheusZero/images/post/POO/71.png)


#### Interfaces

![](/TheusZero/images/post/POO/39.png)

> colecciones de metodos abstractos y propiedades constantes, en que se especifican que se hara, es decir, que definen metodos pero sin cuerpo, dictan que se hara, pero no como se implementara.
> Las clases hijas deeben definir el comportamiento de todo metodo abstracto
>> ![](/TheusZero/images/post/POO/37.png)
>> ![](/TheusZero/images/post/POO/38.png)

![](/TheusZero/images/post/POO/81.png)
![](/TheusZero/images/post/POO/82.png)
![](/TheusZero/images/post/POO/83.png)
![](/TheusZero/images/post/POO/84.png)

[EmployeeSortTest.java](https://gitlab.com/utfsm-elo/elo329/-/blob/master/codigos/08-JavaInterfaces/EmployeeSortTest.java)

En Java cada clase puede tener solo una clase base (en Java no hay
herencia múltiple), pero cada clase puede implementar varias interfaces.

Cuando existe relación **es-un** con varias categorías del mundo real,
usamos herencia con una de ellas e interfaces para exhibir el
comportamiento esperado para las otras.

Se **cumple también el principio de sustitución.** Instancias de la clase que
**implementa** una Interfaz pueden ser usadas donde hay una referencia a
una instancia de la interfaz.

No se permite crear instancias (objetos) de una Interfaz. Por la misma
razón que no se puede crear instancias de clases abstractas, dado que
no se tienen la implementaciones.
```new InterfazX(); // Error!```

Todos los métodos de una Interfaz son públicos. No es necesario
indicarlo

Pueden incluir constantes. En este caso son siempre public static final.
[TimeGoesByTest.java](https://gitlab.com/utfsm-elo/elo329/-/blob/master/codigos/08-JavaInterfaces/TimeGoesByTest.java)

> Clase abstracta vs Intefaz
>> la principal diferencia entre una clase abstracta y una normal, es que la clase abstracta tiene almenos (por obligacion) un metodo abstracto
>>> metodo abstracto = no posee cuerpo, es un metodo que solo define que existe, pero que no tiene que cuerpo, es decir, que no explica que se hara.
> Como java no permite la herencia multiple, son las interfaces las que se usan, siendo estas contratos donde se estipula que se debe hacer en cada tarea y seran las clases hijas las encargadas de realizar estas tareas. 

#### metodo clone en Object 

El método clone() existe con acceso protegido en la clase Object.

Para invocarlo sobre un objeto se requiere que la clase del objeto
implemente la interfaz Cloneable, lo cual significa que debemos
redefinir el método clone.

Para generar un clone, debemos hacerlo invocando el método
clone de la clase Object.

El método clone de Object crea y retorna un objeto con igual
estructura al objeto llamado e inicializa todos sus campos con el
mismo contenido de los campos del objeto llamado.

Los contenidos de cada campo no son clonados. Hasta aquí se le
llama copia baja. Para una copia profunda ( o completa) se debe
llamar el método clone de cada atributo.

> ![](/TheusZero/images/post/POO/91.png)
>> [Ver CloneTest.java](http://profesores.elo.utfsm.cl/~agv/elo329/JavaProg/CloneTest/CloneTest.java)

#### metodo copiar, Copia baja y profunda

![](/TheusZero/images/post/POO/66.png)

**Copia baja** es aquella donde la **copia de un objeto** se efectúa **copiando el valor de sus atributos** y **cuando
un atributo es un objeto sólo se copia su referencia**, como consecuencia **en copia baja los atributos
objetos son compartidos entre el objeto original copiado y su destino**.

Copia profunda es aquella donde la copia de un objeto sólo copia los atributos escalares (no objetos) y
los objetos inmutables (que no pueden cambiar) y para aquellos objeto mutables se generan copias
profundas de cada uno. De este modo se genera una nueva versión del objeto que no comparte objetos
mutables con el objeto copiado.

El método clone() implementa copia o profunda

![](/TheusZero/images/post/POO/41.png)

>> Copia profunda: todas las variables del objeto copiado contienen el mismo valor que el objeto original, excepto aquellas variables que se refieren a otros objetos. Las variables que se refieren a otros objetos apuntarán a los objetos nuevos copiados y ya no serán los objetos referenciados originales. En otras palabrasCopia profunda copia los objetos a los que hace referencia el objeto a copiar
>
>> Copia superficial:Todas las variables del objeto copiado tienen el mismo valor que el objeto original, mientras que todas las referencias a otros objetos todavía apuntan al objeto original. En otras palabrasLa copia superficial solo copia el objeto en cuestión, no los objetos a los que hace referencia.

El método clone() existe con acceso protegido en la clase Object.

Para invocarlo sobre un objeto se requiere que la clase del
objeto implemente la interfaz Cloneable, lo cual significa que
debemos redefinir el método clone.

Para generar un clone correcto, debemos hacerlo invocando
el método clone de la clase Object.

El método clone de Object crea y retorna un objeto con igual
estructura al objeto llamado e inicializa todos sus campos
con el mismo contenido de los campos del objeto llamado.
Los contenidos de cada campo no son clonados (hasta aquí
se le llama copia baja), luego para una copia completa
(profunda) se debe llamar el método clone de cada atributo.

#### Poliformismo

> Hay varias formas de polimorfismo:
>> Cuando vía subtipo asignamos una instancia de una subclase a una referencia de la clase base. Ej. Un Estudiante adopta el rol de Persona.
>
>> Cuando invocamos el mismo nombre de método sobre instancias de distintas clases
>
>> Cuando creamos múltiples métodos de igual nombre
> ![](/TheusZero/images/post/POO/72.png)


El uso de abstracciones e interfaces son formas de poliformismo. (clase padre define un metodo y las hijas lo expanden para su uso especifico).

Polimorfismo es un concepto donde un
mismo nombre puede referirse a objetos de clases
diferentes que están relacionadas por una clase base
común.

Es una relacion de tipo herencia, donde un objeto de la superclase (clase padre) puede almacenar un objeto de cualquiera de las subclases (clases hijas)

Esto significa que la clase padre o superclase es compatible con los tipos que derivan de ella pero no al reves.

![](/TheusZero/images/post/POO/43.png)
![](/TheusZero/images/post/POO/44.png)
![](/TheusZero/images/post/POO/45.png)

#### ligadura

La ligadura dinámica se encarga de ligar o relacionar la llamada a un método con el cuerpo del método que se ejecuta finalmente.

> Ligado Dinámico
> Al momento de la compilación el compilador intenta resolver el método que corresponda según su nombre y parámetros. Si la superclase y la clase base tienen definido el mismo método ¿Qué implementación se invoca?
> 
> **Si el método en la clase de la referencia no es privado, static, o final, se invocará en forma dinámica.**
>> **se invocará el método definido en la clase del objeto y no el método de la clase de la referencia. A esto se le llama ligado dinámico.**
> Por ello, si una clase derivada redefine el mismo método, éste será invocado para sus instancias (excepto para los casos nombrados).

> Ejemplo importante
> ![](/TheusZero/images/post/POO/73.png)
> Se crea una clase manager hija de empleado, en la clase manager se hace la sobreescritura con Overwrite del metodo getSalary()
> que posee la clase padre Empleado, al momento de crear el objeto de tipo manager y almacenarlo en un array de tipo empleados, es decir, del tipo de la clase padre,
> entonces en el objeto boss creado se emplea el principio de sustitucion, pero al momento de llamar a get.salary(), si el objeto boss tiene como referencia ahora a la clase empleado, se ejecuta el metodo de getsalary() para boss o para empleado?
>> La respuesta es que, si el metodo getsalary() fue sobreecrito, es decir, que su cuerpo de codigo cambio dentro de la clase hija, entonces se ejecuta el getsalary() que la clase hija posee,
>> debido a que al jefe se le deben aplicar los bonos, es decir que de otra forma, que si el cuerpo del getsalary() cambio, entonces se emplea este. Esto se hace en tiempo de ejecucion
> De otra forma, si hay un metodo que no esta definido en empleado, pero si en manager, este no se puede usar en el principio de sustitucion
> ![](/TheusZero/images/post/POO/74.png)

> Si la superclase -Employee- y la clase hija -Manager- tienen
> implementado el mismo método -getSalary()- ¿Qué implementación se
> invoca?
> 
>> Si el método en la clase de la referencia no es privado, static, o final, se invocará en forma dinámica.
> 
>> Ligado dinámico es la ejecución de un método según su implementación en la clase del objeto apuntado y no según la clase de la referencia usada.

>>Consiste en realizar el proceso de ligadura en tiempo de ejecución siendo la forma dinámica del objeto la que determina la versión del método a ejecutar.
>
>>Se utiliza en todos los métodos de instancia de Java que no son privados ni final.

Gracias al ligado dinámico es posible hacer programas fácilmente
extensibles.

Creamos una clase derivada y redefinimos los comportamientos que
deseamos.

No se requiere recompilar las clases existentes. Esto es usado
intensamente al utilizar clases predefinidas en el lenguaje.

Si deseamos impedir que una de nuestras clases se use como base,
la declaramos como final. Éstas no se pueden derivar.
final class Manager extends Employee { ... }, 
Si un método es final, ninguna subclase puede redefinirlo.

El ligado dinámico es más lento que el estático (> tiempo de
ejecución).

> Funcionamiento de la Ligadura Dinámica:
>> Resolución de conflictos entre Superclases y Subclases:
>
>> Cuando existe un conflicto entre un método de una superclase y un método de la subclase, el comportamiento correcto es que el método de la subclase sobrescriba al de la superclase.
>
>> Si estamos llamando a un método de la subclase desde una variable que ha sido declarada del tipo de la superclase. ¿Cómo se consigue que funcione correctamente?
>
> Ligadura Dinámica:
>> Significa que la forma dinámica del objeto determina la versión de la operación que se aplicará.
>
>> Esta capacidad de las operaciones para adaptarse automáticamente a los objetos a los cuales se aplican es una de las propiedades más importantes de la orientación a objetos.
>
> Características de la Ligadura Dinámica:
>> Puede variar de un lenguaje a otro, pero básicamente presentan unas características comunes. Los métodos que necesitan ligadura dinámica:
>
>> Deben presentar ligadura dinámica solo aquellos que pueden ser redefinidos.
>
>> Por ejemplo, en Java, los métodos de clase y los métodos de instancia privados y/o finales no presentan ligadura dinámica.
>
>> En Java, si no se especifica nada se entenderá que el método puede ser redefinido y por tanto debe presentar ligadura dinámica

>Ligadura estática:
>> Consiste en realizar el proceso de ligadura en tiempo de compilación según el tipo declarado del objeto al que se manda el mensaje.
>
>> La utilizan (en Java) los métodos de clase y los métodos de instancia que son privados o final (ya que estos últimos no pueden ser sobrescritos).

#### Compilación v/s Ejecución

El compilador verifica que los accesos y métodos invocados
sean válidos en la clase declarada para el identificador o
nombre del objeto.

En tiempo de ejecución, el código ejecutado depende de la
declaración del método invocado. Si corresponde ligado
dinámico, el código ejecutado será el del objeto apuntado por la
referencia.

Debemos distinguir entre la clase de la referencia y la clase del
objeto apuntado por la referencia.

#### Casteo 

acceder a un método definido sólo en una clase derivada con una
referencia de la clase base, es decir, invocar los métodos sólo presentes en Manager

¿Cómo sabemos que e es una referencia a una instancia de
Manger?

Lo podemos preguntar con el operador instanceof.

![](/TheusZero/images/post/POO/75.png)
![](/TheusZero/images/post/POO/76.png)

#### programacion generica
![](/TheusZero/images/post/POO/78.png)

#### array list

es una clase que genera un arreglo variable, para operar sobre el tenemos que usar metodos que vienen
definidos en esta clase ArrayList

![](/TheusZero/images/post/POO/77.png)

esto es programacion generica porque funciona con cualquier tipo de clase creada.

![](/TheusZero/images/post/POO/79.png)

#### la clase class

![](/TheusZero/images/post/POO/80.png)

#### Clases Anidadas

Las clases anidadas son clases definidas al interior de otra clase o
dentro de un método.

> Tres razones para ofrecer esto en Java:
>> Aumenta la encapsulación al agrupar clases usadas solo en una clase.
>
>> Generan código más legible y mantenible.
> 
>> Permiten reducir código fuente.

Cuando usamos instancias de una clase B solo al interior de una clase A, podemos definir B al interior de A.

Puede haber clases anidadas estáticas y no estáticas. A estas últimas
se les llama también clases internas.

> [Ejemplo java.awt.geom.Rectabgle2D](https://docs.oracle.com/javase/9/docs/api/java/awt/geom/Rectangle2D.html)
> la cual define dos clases anidadas: Rectangle2D.Double y Rectangle2D.float.

![](/TheusZero/images/post/POO/86.png)

Las clases internas están asociadas a instancias (objetos) de
clase anfitriona.

Las clases internas tienen acceso a los atributos de la anfitriona
(incluso si son privados) no así las clases anidadas estáticas.

Las clases anidadas estáticas están asociadas a la clase
anfitriona.

Como miembros de la clase anfitriona, las clases anidadas
pueden ser declaradas private, public, protected o del paquete
(cuando omitimos el calificador).

Son útiles para reducir código fuente. Especialmente cuando la
clase solo genera instancias locales.

Son comunes en el desarrollo de interfaces gráficas.

Las clases anidadas existen sólo para el compilador, ya que éste las transforma en
clases regulares separando la clase externa y anidada con signo $

La máquina virtual no distingue clases anidadas de otras no anidadas.

También se pueden definir al interior de un método

> Ejemplo creación de una instancia (en clases public):
>> Clases estáticas anidadas:
> ```OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();```
![](/TheusZero/images/post/POO/87.png)

> ![](/TheusZero/images/post/POO/88.png)
>> [InnerClassTest.java](http://profesores.elo.utfsm.cl/~agv/elo329/JavaProg/InnerClassTest/InnerClassTest.java)
>  ![](/TheusZero/images/post/POO/89.png)
>> [InnerClassMethodTest.java](http://profesores.elo.utfsm.cl/~agv/elo329/JavaProg/InnerClassTest/InnerClassInMethodTest.java)

#### Clases internas anónimas

Si deseáramos proveer de una implementación a los métodos de una
interfaz para crear un único objeto ¿para qué definir una clase?

Cuando necesitamos solo una instancia de una clase que implementa
una interfaz, no necesitamos darle un nombre. Decimos que tal clase es
interna y anónima.

>  ![](/TheusZero/images/post/POO/90.png)
>> [AnonymousInnerClassTest.java](http://profesores.elo.utfsm.cl/~agv/elo329/JavaProg/AnonymousInnerClassTest/AnonymousInnerClassTest.java)

#### Expresiones Lambda

[PREGUNTAR REVISAR](https://aula.usm.cl/pluginfile.php/2214553/mod_label/intro/10-Java_LambdaExpressions.pdf)

Cuando la implementación de una clases anónima es simple, la sintaxis
de las clases anónimas puede ser excesiva y poco clara.

En estos casos se busca pasar cierta funcionalidad como un argumento
de otro método.

Las Expresiones Lambda permiten tratar funcionalidad como un
argumento, o código como datos.

Las expresiones lambda nos permiten expresar instancias de una clase
de método único de manera más compacta.

> ![](/TheusZero/images/post/POO/92.png)
> ![](/TheusZero/images/post/POO/93.png)

Cuando se trata de un solo método y dado que es aquel de interfaz ActionListener, se puede simplificar y omitirlo,
lo mismo con el nombre de la interfaz. Así se llega a la versión usando un expresión lambda:

> ![](/TheusZero/images/post/POO/94.png)

>





## Excepciones en Java

Los lenguajes orientados a objeto han buscado la forma de facilitar la programación de
las condiciones de error en un programa.

Muchas cosas pueden generar excepciones (o errores): Errores de hardware (falla de
disco), de programa (acceso fuera de rango en arreglo), apertura de archivo
inexistente, ingreso de un depósito negativo, probabilidad mayor que 1, etc.

En lugar de mezclar el código asociado a la lógica principal del programa con el
tratamiento de excepciones, lo cual dificulta la claridad de la tarea principal del
programa, los lenguajes orientados a objeto como **Java y C++ disponen un mecanismo
de excepciones que separa la parte fundamental del código (mayor % de los casos) de
las situaciones de error.**

Una **excepción es un evento que ocurre durante la ejecución de un programa que
rompe el flujo normal de ejecución.** Cuando se habla de excepciones nos referimos a
un evento excepcional.

![](/TheusZero/images/post/POO/95.png)
![](/TheusZero/images/post/POO/96.png)
![](/TheusZero/images/post/POO/97.png)

#### Comportamiento durante ejecución

Cuando se produce una excepción dentro de un método, se crea un objeto
que contiene información sobre la excepción y se retorna en forma inusual
al código llamador con el objeto que explica la excepción.

La rutina receptora de la excepción es responsable de reaccionar a tal
evento inesperado.

**Cuando creamos un objeto para la excepción y lo pasamos al código
llamador decimos que lanzamos una excepción (Throw an exception)**

Si el método llamador no maneja la excepción, se busca hacia atrás en la
pila de llamados anidados hasta encontrarlo.

**Decimos que el manejador atrapa la excepción** (palabra reservada
“catch”)

#### Captura de Excepciones (completo)

> manejo de excepciones:
>> ![](/TheusZero/images/post/POO/98.png)

#### Aspectos Operativos

Dos partes: Quien genera la condición de error (excepción) debe informarla.
Quien es informado debe hacer algo al respecto.

Para lo primero, el método que genera la excepción la informa creando y
lanzando un objeto que porta antecedentes sobre el error.

En Java los objetos lanzados deben ser instancias de clases derivadas de
Throwable. Ej: ```Throwable e = new IllegalArgumentException(“Stack underflow”);throw e;```

#### Tipos de Excepciones

> Las hay de dos tipos
>> Aquellas generadas por el lenguaje Java. Éstas se generan cuando hay
>> errores de ejecución, como al tratar de acceder a métodos de una
>> referencia no asignada a un objeto, división por cero, etc. En este caso no
>> se exige el bloque try
> 
>> Aquellas incluidas por el programador vía paquetes o sus propias clases. Aquí sí se exige bloque try.

El compilador chequea por la captura de las excepciones lanzadas por los
métodos invocados en el código

Si una excepción no es capturada, debe ser relanzada.

#### Reenviando Excepciones: dos formas

![](/TheusZero/images/post/POO/99.png)

#### Creación de tus propias excepciones

Siempre es posible lanzar alguna excepción de las ya definidas en Java (IOException por ejemplo).

También se puede definir nuevas excepciones creando clases derivadas de las clases Error o Exception.

![](/TheusZero/images/post/POO/100.png)

#### Jerarquía de Excepciones

Cuando creemos nuestras excepciones, serán subclases de Exception.

Java prohíbe crear subclases de Throwable.

Java no obliga a manejar o reenviar RuntimeException.

![](/TheusZero/images/post/POO/101.png)

#### Ventajas de las Excepciones

Claridad y simplicidad de la tarea a realizar más frecuentemente.

Propaga los errores hacia atrás hasta el punto donde se puede tomar una
acción.

Se agrupan los errores según su naturaleza.

> Ej:
>> Si hay más de un archivo que se abre, basta con un código para capturar tal caso
>
>> Si se lanzan excepciones que son todas subclases de una base, basta con capturar la base para manejar cualquiera de sus instancias derivadas.

#### ¿Cuándo no podemos relanzar una excepción?

> Hay situaciones en que estamos obligados a manejar una excepción. Consideremos por ejemplo:
> ```java
> class MyApplet extends Applet {
> public void paint (Graphics g) {
> FileInputStream in = new FileInputStream(“input.dat”); //ERROR
> ....
>     }
> }
> ```

La intención es redefinir un método de la clase Applet - método paint- el cual no genera ninguna
excepción. Si un método no genera excepciones la función que lo redefine no puede
lanzar excepciones.

> Lo previo obliga a que debamos hacernos cargos de la excepción.
> ```java
> class MyApplet extends Applet {
> public void paint (Graphics g) {
> try {
>       FileInputStream in = new FileInputStream(“input.dat”); //Posible error
>       ....
>       } catch (Exception e) {//......}
>   }
> }
> ```

![](/TheusZero/images/post/POO/102.png)

#### Cosas a tomar en cuenta

Las excepciones consumen tiempo, no usarlas cuando hay alternativas
mejores, ejemplo [ExceptionalTest.java](https://gitlab.com/utfsm-elo/elo329/-/blob/master/codigos/11-JavaExceptions/ExceptionalTest.java)

Agrupar el manejo de varias excepciones en un único try…

> En cada caso evaluar si es mejor atrapar la excepción o reenviarla a
> código llamador.
>> ```java
>> public void readStuff(String name) throws IOException {
>> FileInputStream in= new FileInputStream(name);
>> ….
>> }
>> ```
> El código que llama al método puede manejar la excepción de mejor forma
> que aquí.

## Programacion JavaFX

programacion de graficas con JavaFX.

#### Programación basada en/dirigida por eventos “Event-Based Programming”: Conceptos (o Event-driven Programming)

Hasta ahora nuestros programas ejecutan instrucciones siguiendo
el orden de llamados definido en método main (*).

Ésta no es la forma como operan los programas con interfaces
gráficas. En éstos el programa debe responder cada vez a una
solicitud del usuario en alguna de las partes de la interfaz gráfica.

¿Cómo monitorear dónde el usuario hará el siguiente click? Para
esto ayuda la programación conducida por o basada en eventos.

#### Programación basada en eventos: Otro paradigma de programación

La programación basada en eventos (o programación dirigida por
eventos) es aquella donde el flujo del programa está determinado por eventos; por
ejemplo, salidas de un sensor, eventos de usuario (mouse, teclado), mensajes desde
otros programas (locales o remotos), etc.

> También puede ser definida como una técnica para estructurar aplicaciones en donde
> la aplicación tiene un loop principal con las siguientes dos secciones:
> Selección o detección de evento
> 
> Manejo o reacción frente al evento
>> ```java
>> Inicialización;
>> Forever do {
>>  Detecte la llegada de un evento;
>>  Ejecute acción definida para ese evento;
>> }
>> ```

#### Otro paradigma de programación (cont.)

En sistemas embebidos (micro-procesadores /
microcontroladores, etc) y para responder a eventos de
hardware, este modelo se implementa usando
interrupciones en lugar de correr un loop infinito.

Programas basados en eventos pueden ser escritos en
cualquier lenguaje pero esta tarea se facilita en los
lenguajes que proveen abstracciones de alto nivel para ello.

En **Java el loop infinito lo proporciona el ambiente gráfico de
Java.** El programador solo debe registrar el código a
ejecutar ante la ocurrencia de cada evento de interés.

#### Uso de programación de eventos en GUIs

Este modelo tiene gran aplicación en la programación de interfaces
gráficas de usuarios.

> Hasta ahora, los programas de consolas típicos siguen un flujo
> secuencial en que típicamente se tienen ciclos:
>> entrada->procesamiento->salida

Cuando programamos una Interfaz Gráfica de Usuario (GUI: Graphics
User Interface) debemos tomar en cuenta la variedad de posibles
interacciones con el usuario.

> En lugar de un único flujo de entrada de datos por consola, las GUIs
> permiten muchas más acciones del usuario.
>>  Por ejemplo: es posible presionar botones gráficos, escribir texto en un
>>  campo de texto, o mover algún scrollbar.
> 
>>  ¿Cómo podemos estar atentos a tantas cosas al mismo tiempo?

#### Modelo

Una forma de manejar todo tipo de posibles interacciones de usuarios es el **uso
de interrupciones;** por ejemplo, cuando suena el timbre o teléfono en casa.

De esta manera la CPU no pierde tiempo “mirando” los posibles eventos de
usuarios, sino simplemente responde al evento y reanuda su procesamiento
normal (otras tareas).

Lenguajes como Java nos permiten definir y **manejar interrupciones o eventos
por software.**

La API de Java permite crear clases de objetos, llamados listeners o hanlder,
que responden a eventos causados por la GUI.

La API de Java tiene **interfaces (listeners o handlers)** que deben ser
implementadas por las clases que atenderán (manejarán) los eventos de interés.

Los métodos de la interfaz (“equivalen a las rutinas de servicio de interrupción”)
son llamados cuando un evento específico ocurre.

#### Pasos para programar respuestas a Eventos

![](/TheusZero/images/post/POO/103.png)

Un **handler** es una instancia de una clase definida por el usuario. Esta clase
implementa los métodos de una Interfaz (estos métodos equivalen a las
rutinas para atender los eventos de interés).

Las componentes gráficas de Java definen el métodos asociados a eventos y
los datos pasados al invocarlo.

Veamos el caso de una ventana de nivel superior en Java (son aquellas
que se pueden mover libremente en la pantalla - desktop)
[CloseableStage.java](http://profesores.elo.utfsm.cl/~agv/elo329/JavaProg/JavaFX/CloseableStage.java) Se verificó compilación con Java SE 8u60

![](/TheusZero/images/post/POO/104.png)
![](/TheusZero/images/post/POO/105.png)

#### Relación estática de clases (generada con Jprasp)

![](/TheusZero/images/post/POO/106.png)
![](/TheusZero/images/post/POO/107.png)

#### Explicación

La clase CloseableStage que extiende la clase Application, es la encargada de
ejecutar el programa gráfico.

Un objeto de la clase Stage corresponde a una ventana gráfica en el programa. La
aplicación puede crear tantas ventanas como lo desee creando múltiples objetos
Stage.

Una **instancia de MyWindowHandler es registrada con el método setOnCloseRequest
a la Stage** (es como configurar quién atenderá los eventos de cierre la ventana).
**Cuando el evento ocurre**, la máquina virtual Java lo detecta y verifica si hay handlers
esperando por ese evento. Si los hay, en este caso automáticamente llama al método
**handle** de la interfaz EventHandler.

En este ejemplo, la interfaz EventHandler es implementada por la clase
MyWindowHandler, así su instancia puede responder a los eventos de la stage en
que fue registrado el objeto.

La mayoría de las otras interfaces para eventos no difieren mucho. Veremos otro
ejemplo.

#### Entrada en Campo de texto

Supongamos que queremos leer lo ingresado en un campo de
texto y luego copiarlo en un texto de la ventana (label). [SimpleMimic.java](http://profesores.elo.utfsm.cl/~agv/elo329/JavaProg/JavaFX/SimpleMimic.java)

#### Diagrama de secuencia

**Situación:** Creación de handler (manejador del evento) y su registro en la componente
gráfica (JTextField).

![](/TheusZero/images/post/POO/108.png)

Se espera que este tipo de diagramas puedan ser hechos antes de escribir el código
(alguien experimentado).

Estos diagramas son una buena documentación del código.

Situación (caso de uso): Usuario ingresa nuevo texto y presiona “Enter”. Esto gatilla el evento
esperado

![](/TheusZero/images/post/POO/109.png)

Es recomendable tener bien clara esta interacción de objetos. Este diagrama sirve además
como documentación.

TextField y Label pertenecen a la biblioteca JavaFX. Luego, solo hay que escribir el código
para las otras tres clases.

#### Entrada en Campo de texto: versión 2

Esta versión separa roles -Panel y EventHandler-, para este
problema simple probablemente no se justifica.

La idea es explorar otras situaciones posibles.

[Mimic.java](http://profesores.elo.utfsm.cl/~agv/elo329/JavaProg/JavaFX/SimpleMimic.java)

#### Gráficas y Eventos

> Oyente de acción (ActionListener)
>> metodo que agrega un oyente de accion, es decir, que cuando suceda algo entonces accionara una respuesta, se usa para los botones de JavaFX

#### AWT, Swing y JavaFx

En sus orígenes Java introdujo la **AWT** (Abstract Window Toolkit). Ésta “creaba” los
objetos delegando su creación y comportamiento a herramientas nativas de la
plataforma donde corre la Máquina Virtual Java.

Este esquema condujo a problemas por diferencias en distintas plataformas y S.O.

La solución fue desarrollar todos los objetos de la GUI basados solo en elementos
muy básicos y comunes en todas las plataformas. **Así surge Swing.**

Luego surge la guerra de plataformas de software para desarrollar “Rich Internet
applications” (RIAs): Adobe Flash y Microsoft Silverlight. En esa época Oracle
desarrolla JavaFx.

Adobe decidió discontinuar Flash el 2017 y apoyar HTML5. Soporte Flash sería
removido de los navegadores en Dic. 2020.

**JavaFx** permite desarrollar aplicaciones de escritorio y RIA (aplicaciones que corren
en navegador).

#### javaFX

En este curso usaremos JavaFX

JavaFX es una biblioteca usada para construir aplicaciones
gráficas en Java

JavaFX fue desarrollado por la empresa “See Beyond”, esta
empresa fue comprada por Sun Microsystems el año 2005.

El año 2009, Oracle compra a Sun Microsystems y continúa el
desarrollo de JavaFX.

> El año 2018 Oracle declara que:
>> Seguirá soportando AWT y Swing hasta al menos 2026
> 
>> Está trabajando con terceras partes para mantener JavaFx como un módulo separado y de código abierto.

### Instalación de JavaFX

Desde la versión 11 de Java, JavaFX viene como un
módulo separado del JDK.

Puede acceder a las instrucciones de instalación para los
IDEs más populares y para los Sistemas Operativos
Windows/Linux en https://openjfx.io/openjfx-docs/

Revisaremos el proceso de instalación para el IDE IntelliJ
IDEA

[Instalación de JavaFX en IDE IntelliJ IDEA](https://aula.usm.cl/pluginfile.php/2214553/mod_label/intro/13-JavaFXGraphicsProgramming.pdf)

#### Estructura Básica de JavaFX

> **javafx.application.Application** es el punto de entrada para una aplicación JavaFX

> **Javafx.stage.Stage** (stage = escenario) es la clase contenedora de nivel superior
>> El escenario primario es construido por la plataforma

> **javafx.scene.Scene** (escena)es la clase contenedora de todo el contenido en una escena gráfica.

> **javafx.scene.Node** es la clase base para
> todos los nodos gráficos de una escena

![](/TheusZero/images/post/POO/110.png)

#### Estructura Básica de JavaFX

Internamente una escena contiene un
grafo de Nodos con una estructura similar
a la de un estructura de árbol (como el de
la figura).

Esta estructura es la representación
interna del contenido de la escena.

Un Nodo es un objeto visual del grafo de
una escena.

![](/TheusZero/images/post/POO/111.png)

#### MyFirstJavaFX

```java
import javafx.application.Application;
import javafx.stage.Stage;
import javafx.scene.Scene;
import javafx.scene.control.Button;
public class MyFirstJavaFX extends Application {
 @Override // Override the start method in the Application class
 public void start(Stage primaryStage) {
// Create a button and place it in the scene
 Button btOK = new Button("OK");
 Scene scene = new Scene(btOK, 200, 250);
 primaryStage.setTitle("MyJavaFX"); // Set the stage title
 primaryStage.setScene(scene); // Place the scene in the stage
 primaryStage.show(); // Display the stage
 }
 /**
 * The main method is only needed for the IDE with limited JavaFX support.
 * Not needed for running from the command line.
 */
 public static void main(String[] args) {
 launch(args);
 }
}
```
![](/TheusZero/images/post/POO/112.png)

#### MultipleStageDemo

```java
// Multiple stages can be added beside the primaryStage
public class MultipleStageDemo extends Application {
 @Override // Override the start method in the Application class
 public void start(Stage primaryStage) {
// Create a scene and place a button in the scene
 Scene scene = new Scene(new Button("OK"), 200, 250);
 primaryStage.setTitle("MyJavaFX"); // Set the stage title
 primaryStage.setScene(scene); // Place the scene in the stage
 primaryStage.show(); // Display the stage
 Stage stage = new Stage(); // Create a new stage
 stage.setTitle("Second Stage"); // Set the stage title
// Set a scene with a button in the stage
 stage.setScene(new Scene(new Button("New Stage"), 100, 100));
 stage.show(); // Display the stage
 }
 public static void main(String[] args) {
 launch(args);
 }
}
```
![](/TheusZero/images/post/POO/113.png)

#### Panes (cristales), UI Controls, y Shapes

![](/TheusZero/images/post/POO/114.png)

#### Layout Panes

JavaFX provee varias tipos de “cristales” para organizar cómo se despliegan
los nodos (objetos gráficos) de un contenedor; por ejemplo, una escena.

![](/TheusZero/images/post/POO/115.png)

#### ButtonInPane

```java
    public class ButtonInPane extends Application {
     @Override // Override the start method in the Application class
     public void start(Stage primaryStage) {
    // Create a scene and place a button in the scene
     StackPane pane = new StackPane();
     pane.getChildren().add(new Button("OK"));
     Scene scene = new Scene(pane, 200, 50);
     primaryStage.setTitle("Button in a pane"); // Set the stage title
     primaryStage.setScene(scene); // Place the scene in the stage
     primaryStage.show(); // Display the stage
     }
     public static void main(String[] args) {
     launch(args);
     }
    }
```

![](/TheusZero/images/post/POO/116.png)

#### Despliegue de alguna Forma (Shape)

Notar la convención para los sistemas de coordenadas en programación, (0,0)
está en la esquina superior izquierda.

![](/TheusZero/images/post/POO/117.png)

Veamos cómo dibujar un círculo (formas de este tipo se ocuparán en Tarea 2)

#### ShowCircleCentered

```java
public class ShowCircleCentered extends Application {
 @Override // Override the start method in the Application class
 public void start(Stage primaryStage) {
// Create a pane to hold the circle
 Pane pane = new Pane();
// Create a circle and set its properties
 Circle circle = new Circle();
 circle.centerXProperty().bind(pane.widthProperty().divide(2));
 circle.centerYProperty().bind(pane.heightProperty().divide(2));
 circle.setRadius(50);
 circle.setStroke(Color.BLACK);
 circle.setFill(Color.WHITE);
 pane.getChildren().add(circle); // Add circle to the pane
// Create a scene and place it in the stage
 Scene scene = new Scene(pane, 200, 200);
 primaryStage.setTitle("ShowCircleCentered"); // Set the stage title
 primaryStage.setScene(scene); // Place the scene in the stage
 primaryStage.show(); // Display the stage
 }
/**
* The main method is only needed for the IDE with limited
* JavaFX support. Not needed for running from the command line.
*/
public static void main(String[] args) {
 launch(args);
 }
}
```

![](/TheusZero/images/post/POO/118.png)

#### Clases Image e ImageView

```java
public class ShowImage extends Application {
 @Override
 public void start(Stage primaryStage) {
// Create a pane to hold the image views
 Pane pane = new HBox(10);
 pane.setPadding(new Insets(5, 5, 5, 5));
 Image image = new Image("header-usm.png");
 pane.getChildren().add(new ImageView(image));
 ImageView imageView2 = new ImageView(image);
 imageView2.setFitHeight(100);
 imageView2.setFitWidth(100);
 imageView2.setRotate(90);
 pane.getChildren().add(imageView2);
 Scene scene = new Scene(pane);
 primaryStage.setTitle("ShowImage");
 primaryStage.setScene(scene);
 primaryStage.show();
 }
 public static void main(String[] args) {
 launch(args);
 }
}
```

![](/TheusZero/images/post/POO/119.png)

#### Formas (Shapes)

JavaFX provee varias clases para representar textos, líneas, círculos,
rectángulos, elipses, arcos, polígonos, polígonos abiertos (polylines).

![](/TheusZero/images/post/POO/119.png)

#### Propiedades y Vínculos





## Preguntas Certamenes

> Explique por qué se recomienda reemplazar los “tabs” por espacios para indentar código fuente.
>> Así la indentación se visualiza de igual forma en distintos editores y sus versiones impresas. El
>> tamaño de cada tab es definido por el entorno, luego lo que se ve indentado en uno puede no
>> estarlo en otro.

> Nombre y explique tres características que comparten los lenguajes orientados a objetos.
>> Herencia: la posibilidad de definir una clase o tipo de objeto a partir de la definición de otra.
>
>> Subtipo: la posibilidad de usar instancias de clases derivadas donde se espera una instancia de la
>> clase base.
>
>> Ligado dinámico: el código invocado ante un llamado es definido en tiempo de ejecución
>> permitiendo así que el resultado dependa del objeto específico que recibe el llamado. En conjunto
>> con subtipo, permite generar códigos reusables

> La clase Timer está definida en java.util.Timer y en javax.swing.Timer. ¿Qué definición de import debe
> hacer en su código para usar Timer del paquete java.util?
>> import java.util.Timer;
> ¿Cómo lo hace si además de esta clase, en su programa usted requiere crear instancias de Timer el paquete javax.swing?
>> Como antes al inicio uso:
>> import java.util.Timer;
>> Luego cada vez que desee usar una instancia de Timer de javax.swing, uso la versión completa
>> para la clase, esto es:
>> javaxswing.Timer miTiner; /* así cada vez que requiero referirme a instancias de esta clase*/

> Alguien dice: “Sea emp una instancia de Empleado, al asignar emp=null; en todos los casos el espacio de
> memoria referenciado por emp será recolectado por el recolector de basura de java. ¿Está de cuerdo? Explique.
>> No, debido a que podemos tener más de un nombre para un objeto; es decir, pude haber más de
>> una referencia apuntando a un objeto. El recolector de basura sólo recupera el espacio de memoria
>> cuando no hay referencias a ese espacio

> ![](/TheusZero/images/post/POO/25.png)

> Alguien dice: “Si en un archivo tenemos definidas dos clases A y B, sólo una de ellas puede contener el
> método public static void main (String argv[]) {….. }” ¿Está usted de acuerdo? Justifique.
>> No estoy de acuerdo. El método main puede estar en más de una clase. Aquella que use al correr el
>> programa definirá qué método main es usado.

> Alguien dice: Si B hereda de A y hemos declarado: ```B b;``` entonces será un error de compilación si en alguna parte del programa hacemos: ```A a= (A) b;``` ¿Está usted de acuerdo? Justifique.
>>No estoy de acuerdo, pues eso es perfectamente posible. b hereda de A, luego por subtipo puede
>>tomar el lugar donde se espera una instancia de A. Incluso es válido poner: ```B b2 = (B) a;``` debido a que a bien podría ser referencia a instancias de B, en cuyo caso el casteo es posible
>>> PREGUNTAR, que pasaria si B tiene variables que A no tiene? donde quedan?

> ![](/TheusZero/images/post/POO/28.png)
> ```AQUI IRA MI CODIGO```

>> Ejercicio Vectores
> ![](/TheusZero/images/post/POO/29.png)

> La clase C hereda de B, y B hereda de A. A posee un método protegido getPeso(), el cual no es redefinido
> por B. ¿Es posible redefinir este método en C?
>> Sí. Los métodos protegidos dan visibilidad a las clases derivadas.
> Si su respuesta es afirmativa, ¿cómo podemos llamar la implementación de A de getPeso() desde algún
>método de C?
>> La invocación la haríamos con super.getPeso();
>> Esto funciona pues la versión de getPeso() visible en la clase B es justamente aquella definida en A

> Al redefinir un método en una subclase, ¿es posible retornar un objeto de distinta clase al retornado en el método de la super clase? Explique.
>> Sí es posible. Se debe cumplir que la clase del objeto retornado por la redefinición debe ser subclase de la clase del objeto retornado por el método redefinido.
>>> PREGUNTAR

> ¿Cuándo se usa la sentencia import javax.swing.JOptionPane;? ¿Podríamos omitir este “import”?
>> La sentencia import javax.swing.JOptionPane; se usa cuando deseamos crear instancias de la clase JOptionPane, como en:
>> ```JOptionPane obj=new JOptionPane();``` Sí se puede omitir, pero cada vez que deseemos crear una instancia de esa clase debemos usar la especificación completa como en:
>> ```javax.swing.JOptionPane obj=new javax.swing.JOptionPane();```

> Alguien dice: un cuadrado es un rectángulo de lados iguales. Al ver la forma es-un,
> piensa en herencia. Dé dos razones por las que no es bueno definir la clase Cuadrado como heredando de Rectángulo.
>> Al hacerlo estaríamos usando más memoria de la necesaria para almacenar cuadrados.
>
>> Habría problemas al aplicar el principio de sustitución. Si un método espera un rectángulo para crear la portada de un libro, el método no podrá definir un alto distinto de un ancho si el objeto fuera instancia de cuadrado.

> La expresión “hola”==”hola”, ¿es verdadera o falsa? Explique.
>> Es verdadera. Los strings son objetos en Java, pero por tratarse de strings literales, es
>> secuencia de caracteres entre “”, éstos quedan internos en la clase String y el
>> compilador asocia una única referencia a iguales contenidos

> Si las técnicas de orientación a objeto pueden dar solución a los mismos problemas que
> los lenguajes no orientados a objetos, ¿Dé dos razones para su uso común en los lenguajes actuales?
>> La orientación a objeto facilita la reutilización de código.
> 
>> La orientación a objeto facilita el trabajo en equipo

> Juan instaló el JDK de java, Pedro instaló JRE. Mencione dos cosas que puede hacer Juan pero no Pedro.
>> Juan puede compilar programas con javac.
> 
>> Juan puede extraer la documentación de un programa con javadoc

>> Pregunta Importante
> La clase B es derivada de A. En B redefinimos el método público getEdad() de A.
> ¿Cómo podemos invocar getEdad() implementado por A desde otro método en B?
> ¿Cómo desde este método en B podemos invocar getEdad() implementado en B?
>> Para invocar implementación de A, en el método de B pongo: ```super.getEdad();``` // con esto invocamos la implementación de A.
>
>> Para invocar implementación de B, pongo: ```getEdad();``` // Así invocamos la implementación en B desde un método de B.

> ¿Es posible impedir que un método sea redefinido en una clase derivada? Justifique.
> Sí es posible, basta poner agregar el calificador final al método, como en: ```class A { public final int getEdad() {....} ....}```

> a) Para un juego se le pide crear dados de N caras. Estos dados pueden tomar valores dentro del
> conjunto {1,2,3,..., N}. Cree la clase Dado. Ésta permite definir el número de caras en su
> constructor. Si no se señala, se asume 6 caras. Estos dados deben permitir ser lanzados y en
> cualquier momento se puede consultar el valor del último lanzamiento del dado.
> b) Desarrolle Juego, una aplicación Java que usa la clase definida en a) y muestra una interfaz
> gráfica con un botón, el cual lanza un dado al ser presionado, y un área para mostrar el resultado
> del lanzamiento. El número de caras es ingresado por consola vía un argumento en la línea de
> ejecución de esta aplicación.
> c) Señale qué cambio debe hacer a su clase Dado para implementar la interfaz Comparable
> basado en el último lanzamiento de los dados.

> ¿La Programación Orientada a Objeto es un tipo de programación Imperativa o Declarativa? Explique.
>> La Programación Orientada a Objetos (POO) es Imperativa. En la programación Imperativa el
>> programa señala cómo se debe llevar la computación. Éste es el caso de la POO.
>> (Nota: En la programación declarativa se indica qué se debe hacer y las condiciones en las cuales se
>> hace, pero no el cómo se debe hacer)

> Defina con sus palabras los siguientes términos: instancia, clase heredada, principio de sustitución.
>> Instancia es un objeto o ente específico que cumple con la descripción hecha en una clase.
>> Clase heredada: es una clase definida a partir de otra más general llamada clase base, padre o
>> superclase. Una clase heredada reutiliza el código y extiende la clase base haciéndola más específica.
>> Principio de sustitución: es la propiedad de los objetos de poder tomar el lugar donde se esperaba uno de
>> categoría más general. Se da entre instancias de clases derivadas donde se espera una de la base o de
>> jerarquía superior. También se da entre instancias de una clases que toman el lugar donde se espera un
>> objeto que cumpla una interfaz

> ¿Qué hace posible que un mismo byte-code pueda correr en máquinas de distintas arquitecturas y distintos sistemas operativos?
>> Esto se logra por la existencia de una Máquina Virtual Java (JVM) para cada par (arquitectura, sistema operativo).

> Mencione dos usos de la palabra reservada “final”.
>> “final” lo usamos para identificar que un atributo no puede cambiar su valor una vez asignado en su constructor. “final” también lo usamos para indicar que un método no puede ser redefinido en clases derivadas

> ¿Por qué se dice que la relación es-un entre clases es una condición necesaria pero no suficiente para
> identificar relación de herencia entre clases? ¿Qué condición adicional se debe cumplir para que identificar herencia?
>> Es una condición necesaria pues la relación de herencia sólo se da cuando existe la relación es-un entre
>> una instancia de la clase heredada y una instancia de la clase base. No es suficiente pues existen casos
>> de relación es-un pero donde no hay herencia. Un ejemplo de esto es: un cuadrado es un rectángulo de
>> lados iguales. Existe relación es-un pero no herencia.
>> La condición adicional es cumplir el principio de sustitución. En el ejemplo previo el comportamiento de
>> un rectángulo nos permite ensancharlo hasta que su ancho sea, por ejemplo, el doble de su alto. Si en su
>> lugar usáramos un cuadrado, este comportamiento no es posible.

> Mencione dos semejanzas entre clases abstractas e interfaces en Java. Mencione una diferencia entre ambas.
>> Semejanzas: No podemos crear instancias de clases abstractas ni de interfaces. Las clases abstractas y
>> las interfaces poseen métodos no implementados.
> 
>> Diferencia: Una clase pude derivar de sólo una clase abstracta, pero puede implementar múltiples
>> interfaces.

>> ¿Qué imprime el programa Test?
> ![](/TheusZero/images/post/POO/40.png)
>> Preguntar por el ultimo ```A aa = (A)a; aa.quienSoy();```

> Reescriba el programa adjunto para crear una versión que no haga uso de clases internas ni clases anónimas
> ```java
>     public class CreaBotones {
>      public static void main(String[] args) {
>      CreaBotonesFrame frame = new CreaBotonesFrame();
>      frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
>      frame.setVisible(true);
>       }
>     }
>     class CreaBotonesFrame extends JFrame {
>      public CreaBotonesFrame() {
>      setSize(250, 150);
>      CreaBotonesPanel panel = new CreaBotonesPanel();
>      Container contentPane = getContentPane();
>      contentPane.add(sp);
>       }
>     }
>     class CreaBotonesPanel extends JPanel {
>      public CreaBotonesPanel() {
>      creaBoton();
>       }
>      private void creaBoton() {
>      JButton boton = new JButton("Crea Boton");
>      boton.addActionListener( new ActionListener (){
>      public void actionPerformed(ActionEvent event) {
>      creaBoton();
>       };
>      });
>      add(boton);
>      validate();
>       }
>     }
> ```
>> ![](/TheusZero/images/post/POO/42.png)

> ¿Qué pasos involucra el diseño e implementación orientados a objetos?
>> Identificar los objetos relevantes del problema a resolver. Cada categoría de objetos da origen a una clase.
>> Identificar la relación entre las clases.
>> Identificar los atributos y comportamientos o servicios que éstas deben cumplir.
>> Implementar cada uno de los comportamientos o servicios, eventualmente haciendo uso de los servicios ofrecidos
>> por otras clases de objetos.

> Además de mantener el nombre del método y sus parámetros ¿En qué otra(s) cosa(s) debemos poner atención al redefinir un método presente en una clase base?
>> Debemos fijarnos que si retornamos un objeto, éste debe ser instancia de la misma clase del método a redefinir o bien instancia de una clase derivada de ésta.
> 
>> También debemos fijarnos en mantener las excepciones, si éstas no son lanzadas, en la redefinición no podemos
>> lanzar excepciones.

> ¿Es posible tener un programa con implementaciones para el método main en dos clases? Explique por qué no o cómo se usaría tal cosa.
>> Sí es posible.
>
>> Cómo se usaría: Se crean métodos main en dos clases distintas, luego al compliar se generarán los dos .class
>> correspondientes. Para correr cada versión de main, usamos el nombre de la clase correspondiente como
>> parámetro de la máquina virtual Java.

> ¿Qué debemos hacer para dar sentido a la salida: System.out.print(persona); cuando persona es un objeto?
>> Basta redefinir el método toString en la clase correspondiente a persona.

> Como atributo de una clase se tiene static final double valorDolar, cuyo valor es leído desde teclado ¿cómo se debe
> programar tal inicialización? (puede usar pseudo código para la lectura de teclado).
> En la clase donde esta constante está incluir una inicialización estática, del tipo:
> ```java
> static final double valorDolar;
> static {
> Scanner s = new Scanner(System.in);
> valorDolar = s.nextDouble();
> }
> ```

> Al diseñar una solución de software ¿qué lo hace decidir por crear una clase abstracta en lugar de una clase en
> propiedad? ¿qué lo hace optar por crear una interfaz?
>> Creamos una clase abstracta cuando no es posible dar una implementación a alguno de los métodos de la clase.
>> Optamos por una interfaz cuando no se cuenta con lo necesario para implementar cada uno de los métodos no
>> estáticos. También optamos por una interfaz cuando las clases que la implementan ya derivan de alguna otra clase.

> Un segmento de código Java muestra:
> ```
> String texto = “UTFSM”;
> JLabel label = new JLabel(texto);
> …..….. /*Aquí se muestra el label en pantalla y luego*/
> texto = “USM”; repaint();
> ```
> ¿Al actualizar texto en la línea previa, cambia lo desplegado por label en pantalla? Justifique.
>> No cambia. El string pasado en el constructor de JLabel no cambia por la asignación de un nuevo string a texto.
>> En java se pasan referencias. Además los string son inmutables, cualquier invocación de método sobre texto, no
>> cambiará el string originalmente asignado

> ¿Qué crítica se hizo a los lenguajes tradicionales no orientados a objetos que condujo a incorporar excepciones en los
> lenguajes Orientados a Objetos como Java y C++?
>> Que mezclaban el tratamiento de errores (casos poco frecuentes) con la lógica principal del código (objetivo
>> principal del código), dificultando su claridad y mantención futura.

> ¿Qué significa polimorfismo? ¿Cuáles son los distintos tipos de polimorfismo?
> Polimorfismo es la cualidad de usar un mismo nombre para referirse a cosas similares.
>> Algunos tipos de polimorfismo son:
> 
>> a) Cuando vía herencia un mismo nombre, instancia de la clase hoja, puede tomar también el lugar
>> de una instancia de la clase base.
> 
>> b) Hay polimorfismo cuando varias clases implementan una interfaz. Luego podemos crear código
>> genérico en el sentido que depende sólo de los métodos de la Interfaz. Este código genérico puede
>> ser usado con objetos de distintas clases que implementan la interfaz.
> 
>> c) Hay polimorfismo cuando en una clase base definimos métodos abstractos que luego las clases
>> derivadas definen. Este es un caso similar al b).
> 
>> d) Algunos autores también consideran polimorfismo cuando un mismo método puede ser
>> invocado usando diferentes tipos de datos como parámetros (sobrecarga de métodos), pero otros no
>> lo consideran así.
> 
>> Con un par de casos es OK.

> Dé ejemplos simples de dos distintos tipos de polimorfismo
> 
>> Primer ejemplo: Polimorfismo cuando hay herencia.
>> ```java
>> class Persona {
>> ….
>> }
>> class Empleado extends Persona {
>> …
>> }
>> ```
>
>> ```java
>> Segundo caso: Polimorfismo cuando tenemos interfaces.
>> Class Empleado implements Comparable{
>> ….
>> }
>> Empleado[] funcionarios = new Empleado[50];
>> /* Crear los empleados */
>> Array.sort(funcionarios);
>> ```

> ¿Qué es ligado dinámico? Indique un beneficio y un perjuicio de usar esta técnica.
>> Ligado dinámico es la definición en tiempo de ejecución del código a ejecutar ante una
>> invocación de un método.
> 
>> Beneficio: permite crear código reutilizable.
> 
>> Perjuicio: El ligado dinámico es más lento de ejecutar que el estático definido en tiempo de
>> compilación.

> ¿Para qué sirve la clase Class? De un ejemplo simple de su uso.
>> La clase Class permite consultar información sobre la clase de un objeto en tiempo de
>> ejecución.
>> ```java
>> class Source {
>> ..
>> }
>> System.out.println((new Source()).getClass.getName());
>> ```
>> Retorna Source.

> ¿En qué contexto en Java se usan los listeners? Haga un diagrama de secuencia para mostrar los pasos generales para su uso.
>> Los listener se usan para registrar código a ejecutar ante la ocurrencia de un evento.
>> ![](/TheusZero/images/post/POO/46.png)

> ¿Describa por qué motivo se extiende JFrame en el contexto de los GUIs de Java? ¿Qué parte juegan los listeners en esta implementación?
>> Se extiende JFrame porque ésta es una componente gráfica de nivel superior; es decir, puede
>> existir por sí sola en un escritorio.
>> Los listener llevan a cabo la ejecución de la lógica del programa cada vez que un evento ocurre.
>> Otra respuesta es: los listener permiten implementar la programación conducida por eventos.

> ¿Qué beneficios otorgan las excepciones? ¿Cuántos tipos hay y cuales son?
>> El beneficio de las excepciones es separar las condiciones de error de la lógica principal de un
>> segmento de código (o método).
>> Hay de dos tipos, aquellas generadas por el lenguaje; por ejemplo, cuando se accede a una
>> referencia null. El otro tipo son las incluidas por el programador.

> ¿Las excepciones siempre tienen que ser capturadas? ¿Por qué? ¿En qué caso no es necesario
> capturar una excepción? ¿En qué caso no es posible relanzar una excepción?
>> No, por que una excepción también puede ser relanzada.
>> No es necesario capturar excepciones cuando son generadas por el lenguaje (división por cero, etc).
>> No es posible relanzar una excepción cuando estamos redefiniendo un método que no lo hace.

> Para este código utilice instance of y Casteo para lograr que el arreglo staff almacene Managers y
> Employees. También debe poder almacenar valores de bonus en staff de tipo Manager, debe poder
> imprimir toda la información de staff (incluyendo el bono de los Managers). Debe modificar las clases
> y métodos si es necesario.
```java
import java.util.*;
public class Main {
 public static void main(String[] args) {
 Employee[] staff = new Employee[3];
 // fill the staff array with Manager and Employee objects
 staff[0] =
 staff[1] =
 staff[2] =
 // using cast set bonus information for Manager staff to 9999
 for (int i = 0; i < staff.length; i++) {
 ...
 }
 // print out ALL information about all staff including Managers and Employees
 for (int i = 0; i < staff.length; i++) {
 ...
 }
 }
}
class Employee {
 public Employee(String n, double s,
 int year, int month, int day) {
 name = n;
 salary = s;
 GregorianCalendar calendar = new GregorianCalendar(year, month - 1, day);
 // GregorianCalendar uses 0 for January
 hireDay = calendar.getTime();
 }
 ...
}
class Manager extends Employee {
 public Manager(String n, double s,
 int year, int month, int day) {
 super(n, s, year, month, day);
 bonus = 0;
  }
 ...
 private double bonus;
}
```
> Solucion
```java
import java.util.*;
/**
 * @author tomas agustin
 */
public class Main {
 public static void main(String[] args) {
 Employee[] staff = new Employee[3];
 // fill the staff array with Manager and Employee objects
 staff[0] = new Manager("Carl Cracker", 80000, 1987, 12, 15); 4 pts
 staff[1] = new Employee("Harry Hacker", 50000, 1989, 10, 1);
 staff[2] = new Employee("Tommy Tester", 40000, 1990, 3, 15);
 // using cast set bonus information for Manager staff to 9999
 for (int i = 0; i < staff.length; i++) {
 if (staff[i] instanceof Manager) { 5 pts
 Manager m = (Manager) staff[i];
 m.setBonus(9999);
 }
 }
 // print out information about all staff
 for (int i = 0; i < staff.length; i++) {
 Employee e = staff[i]; 8 pts.
 System.out.print("name=" + e.getName() + ",salary=" + e.getSalary());
 if (e instanceof Manager) {
 Manager m = (Manager) e;
 System.out.print(",bonus=" + m.getBonus());
 }
 System.out.println();
 }
 }
 }
}
class Employee {
 public Employee(String n, double s,
 int year, int month, int day) {
 name = n;
 salary = s;
 GregorianCalendar calendar = new GregorianCalendar(year, month - 1, day);
 // GregorianCalendar uses 0 for January
 hireDay = calendar.getTime();
 }
 public String getName() { 4 pts resto de clase
 return name;
 }
 public double getSalary() {
 return salary;
 }
 public Date getHireDay() {
 return hireDay;
 }
 public void raiseSalary(double byPercent) {
 double raise = salary * byPercent / 100;
 salary += raise;
 }
 private String name;
 private double salary;
 private Date hireDay;
}
class Manager extends Employee {
 public Manager(String n, double s,
 int year, int month, int day) {
 super(n, s, year, month, day);
 bonus = 0;
 }
 public double getSalary() { 4 pts resto de clase
 double baseSalary = super.getSalary();
 return baseSalary + bonus;
 }
 public void setBonus(double b) {
 bonus = b;
 }
 public double getBonus() {
 return bonus;
 }
 private double bonus;
}
```

> Modifique el código anterior para tener una clase abstracta base que se llame Person. En main
> utilice un ```ArrayList<Person> persons = new ArrayList<Person>();``` para contener los Employees y
> Managers. Replique la funcionalidad de main del problema 9 con el ArrayList, muestre los cambios
> del código.
```java
abstract class Person
{
...
}
class Employee extends Person
{
...
}
class Manager extends Person
{
…
}
```
> Solucion
```java
import java.util.*;
public class Main {
 public static void main(String[] args) {
 ArrayList<Person> persons = new ArrayList<Person>();
 // fill the persons list with Manager and Employee objects
 persons.add(new Manager("Carl Cracker", 80000, 1987, 12, 15)); 4 pts.
 persons.add(new Employee("Harry Hacker", 50000, 1989, 10, 1));
 persons.add(new Employee("Tommy Tester", 40000, 1990, 3, 15));
 // using list set bonus information for Manager staff to 9999
 for (int i = 0; i < persons.size(); i++) {
 if (persons.get(i) instanceof Manager) { 3 pts.
 Manager m = (Manager) persons.get(i);
 m.setBonus(9999);
 }
 }
 for (int i = 0; i < persons.size(); i++) {
 persons.get(i).print(); 6 pts.
 }
 }
}
abstract class Person {
 abstract void print();
}
class Employee extends Person {
public Employee(String n, double s, int year, int month, int day) {
 name = n;
 salary = s;
 GregorianCalendar calendar = new GregorianCalendar(year, month - 1, day);
 // GregorianCalendar uses 0 for January
 hireDay = calendar.getTime();
 }
 public String getName() {
 return name;
 }
 public double getSalary() {
 return salary;
 }
 public Date getHireDay() {
 return hireDay;
 }
 public void raiseSalary(double byPercent) {
 double raise = salary * byPercent / 100;
 salary += raise;
 }
 public void print() { 4 pts
 System.out.println("name=" + name + ",salary=" + salary);
 }
 private String name; 2 pts atributos
 private double salary;
 private Date hireDay;
}
class Manager extends Person {
 public Manager(String n, double s, int year, int month, int day) {
 bonus = 0;
 name = n;
 salary = s;
 GregorianCalendar calendar = new GregorianCalendar(year, month - 1, day);
 // GregorianCalendar uses 0 for January
 hireDay = calendar.getTime();
 }
 public String getName() {
 return name;
 }
 public Date getHireDay() {
 return hireDay;
 }
 public void raiseSalary(double byPercent) {
 double raise = salary * byPercent / 100;
 salary += raise;
 }
 public double getSalary() {
 return salary + bonus;
 }
 public void setBonus(double b) {
 bonus = b;
 }
 public double getBonus() {
 return bonus;
 }
 public void print() { 4 pts
 System.out.println("name=" + name + ",salary=" + salary+ ",bonus=" + bonus);
 }
 private double bonus; 2 pts por atributos
 private String name;
 private double salary;
 private Date hireDay;
}
```
> [ejercicios aca, tambien hay uno con MouseHandler](http://profesores.elo.utfsm.cl/~agv/elo329/1s13/grades/C1_1s13_Sol.pdf)

> ¿Cuál es la diferencia entre un objeto real y un modelo de un objeto real? ¿Qué debemos incluir en el modelo?
>> El modelo de un objeto real imita o representa algunas de las características del objeto real. (La realidad es
>> muy compleja para ser representada en su totalidad.)
>> El modelo debe incluir lo necesario para obtener resultados que semejen la realidad dentro del grado de
>> precisión deseado

> Indique qué respondería si en una entrevista de trabajo el preguntan ¿Qué es herencia?
>> Herencia es un mecanismo que permite definir una clase extendiendo la definición de otra.
>> Para que haya herencia debe existir la relación “es-un” y la propiedad de subtipo entre ambas clases.

> Si en la creación de una clase, un programador opta por un nombre de archivo distinto al de la clase ¿se genera
> algún problema? Refiérase al caso en que la compilación es por consola y considere dos casos: i) la clase
> incluye el método main, ii) la clase es usada por la aplicación pero no incluye el método main.
>> Sí se genera un problema. Casos:
> 
>> i) El comando para compilar debe usar el nombre del archivo, pero el comando para ejecutar debe usar el
>> nombre de la clase.
> 
>> ii) En este caso el problema es mayor pues la compilación de la aplicación arroja error al no encontrar la
>> implementación de la clase por usar otro nombre en el archivo. El usuario deberá compilar esa clase primeroo
>> y luego otras que la ocupen.
> 
>> (Nota: En ambos casos no es algo recomendado.)

> Un amigo le pide ayuda para superar el siguiente error de compilación:
> ```Python
> agustin@agustin-Satellite-P55-A:~/teaching/elo329/1s14/Assignments/T2/source$ javac Etapa1/PhysicsLab.java
> Etapa1/PhysicsLab.java:25: error: cannot find symbol
> private void createConfiguration(MyWorld world) {
> ^
> symbol: class MyWorld
> location: class PhysicsLab_GUI
> ```
> Si su amigo no puede cambiar el comando para compilar ¿qué consejo de da usted?
>> Debe configurar la variable de ambiente CLASSPATH parra incluir en ella el directorio donde se encuentre el código fuente.

> ![](/TheusZero/images/post/POO/47.png)

> ¿Cuándo debemos poner la palabra reservada “throws” en la declaración de un método? Por ejemplo en:
> ```public void doio (InputStream in, OutputStream out) throws IOException {...}```
>> Se debe poner cuando el método invoca código que puede generar excepciones y no utiliza la sentencia trycatch. También se debe utilizar cuando el código del método lanza expeciones con sentencia throw.

> Un programador afirma: “Cuando existen clases anónimas en una aplicación, no existirá archivo separado .class para esa clase” ¿Está usted de acuerdo? Justifique.
>> No. El compilador genera un archivo .class por cada clase anónima o no del código. La clase anónima
>> aparecerá con el nombre de la clase que la contiene seguido de un punto y un número.

> Desarrolle una aplicación gráfica en Java que muestre un texto indicando el estado del botón izquierdo del mouse
> (presionado o no) y otro texto para indicar si el mouse se ha arrastrado (drag). El arrastrado concluye cuando el botón izquierdo es liberado.
```java
import java.awt.event.*;
import javax.swing.*;
import java.awt.event.MouseAdapter;
import java.awt.BorderLayout;
public class MouseTest extends JFrame { // 5 puntos constructor
 MouseTestGUI gui = new MouseTestGUI(); // pudo ir en constructor
 public MouseTest() {
 setTitle("Mouse Test");
 setSize(200,50);
 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
 getContentPane().add(gui);
 setVisible(true);
 }
 public static void main( String[] args) { // 5 puntos
 MouseTest mimic = new MouseTest();
 }
}
class MouseTestGUI extends JPanel {
 private JLabel pressedState = new JLabel("Mouse State"); // 5 puntos atributos
 private JLabel draggedState = new JLabel("Dragging State");
 public MouseTestGUI() { // 5 puntos constructor
 super(new BorderLayout()); // it's OK defaut layout manager
 add(pressedState,BorderLayout.PAGE_START);
 add(draggedState, BorderLayout.CENTER);

 MouseAdapter listener = new MouseAdapter(){ // 9 puntos implementación de listeners
 public void mousePressed(MouseEvent e) {
 if (e.getButton()==MouseEvent.BUTTON1) // it's Ok if missing.
 pressedState.setText("Mouse Pressed");
 }
 public void mouseDragged(MouseEvent e) {
 draggedState.setText("Dragging Mouse");
 }
 public void mouseReleased(MouseEvent e) {
 draggedState.setText("Not Dragging");
 pressedState.setText("Mouse Released");
 }
 };
 addMouseMotionListener(listener); // 5 puntos registro de listeners
 addMouseListener(listener);
 }
}
```

> ¿Qué diferencia hay entre programación imperativa y declarativa? ¿A cuál de ellas corresponde la
> programación orientada a objetos? Justifique
>> En la programación declarativa se especifica el resultado deseado y no la forma de obtenerlo, en cambio
>> en programación imperativa se indican los pasos para obtener el resultado.
>> La programación orientada a objetos es imperativa.

> Indique qué respondería si en una entrevista de trabajo le preguntan ¿Qué es ligado dinámico?
> ¿Existe o no relación entre ligado dinámico y la programación genérica? ¿Si existe, cuál sería esa
> relación; si no, explique?
>> Ligado dinámico es una propiedad de los lenguajes orientados a objetos que consiste en la determinación
>> en tiempo de ejecución del código a ejecutar ante la invocación de un método. Este código queda definido
>> por el objeto que recibe la invocación y no por la referencia usada para invocar el método.
>> Sí existe relación. Gracias al ligado dinámico es posible tener métodos genéricos, lo cual hace posible la
>> reutilización de código.
>> Nota: Ejemplo: el método para ordenar datos dentro de un arreglo sólo requiere que sus elementos sean
>> comparables según cada clase de objeto lo defina

> En un archivo Java se ocupa la instancia t1 de la clase Timer del paquete javax.swing, y la instancia
> t2 de la clase Timer del paquete java.util. Suponga que éstos son los únicos objetos del archivo.
> Muestre qué pondría usted en la sección “import” y las instrucciones usadas por usted para crear las
> instancias t1 y t2. Para t1 use constructor Timer(int delay, ActionListener listener), pata t2 use
> constructor por omisión.
```
Bajo inport no iría código.
javax.swing.Timer t1 = new javax.swing.Timer( “delay”, myListener); /* siendo myListener un
objeto subtipo de ActionListener */
java.util.Timer t2 = new java.util.Timer();
```

> Un compañero le pregunta: “¿Cómo sé si debo o no redefinir el método clone de una clase para
> generar copias de instancias de esa clase?” ¿Cuál sería su respuesta?
>> Se debe redefinir el método clone si la clase tiene objetos no instancias de String como atributos y el
>> problema requiere usar semántica equivalente a copia profunda

> ¿Cuál es la función de los layout manager? ¿En qué clase se especifica cuál usar?
>> Su función es facilitar la organización del espacio en una interfaz gráfica de manera que ante cambios de
>> tamaño de la ventana la posición de los objetos sea la deseada.
>> Se especifica en la instancia de la clase panel.

> Mencione dos ventajas de la incorporación de manejo de excepciones en lenguajes orientados a
> objetos, respecto de lenguajes no orientados a objetos como C.
>> El código que implementa la lógica del programa se separa del código para atender las condiciones
>> de excepción. Esto facilita la claridad y mantención del código.
>> Varias situaciones de error pueden ser agrupadas y manejadas en forma conjunta.

> ¿Qué diferencia existe entre una clase anidada estática de aquella anidada no estática?
>> Si tenemos la clase A y la clase B anidada dentro de A. Dé un ejemplo de creación de una instancia
>> de B cuando ésta está definida como estática.
>> La clase anidada no estática puede acceder a todos los métodos y atributos de la clase anfitriona. Las
>> clases anidadas estáticas sólo pueden acceder a métodos estáticos de la clase anfitriona.
>> Ejemplo: ```A.B b = new A.B();```

> Defina método, atributo y referencia en un lenguaje orientado a objetos como Java.
>> Método: es el miembro función de una clase. Es el que permite modelar el comportamiento de una clase.
> 
>> Atributo: es un miembro dato de una clase. El conjunto de atributos permiten almacenar el estado de un objeto.
> 
>> Referencia: es el nombre con el cual identificamos un objeto específico. Usamos la referencia para acceder a los métodos y atributos de un objeto específico.

> ¿Qué condición (es) se debe(n) cumplir para que haya una relación de herencia entre dos clases?
> Mencione dos clases donde haya relación de herencia y explique cómo se cumple esta(s)
> condición(es).
>> Se deben satisfacer dos condiciones: debe existir una relación es-un entre ellas y además debe haber una
>> relación de subtipo entre ambas.
>> La clase Bola hereda de ElementoFisico. Se cumple relación es-un debido a que una Bola es un Elemento
>> Físico. Además, si se requiere un elemento físico, una bola puede cumplir ese rol de buena forma al tener
>> las propiedades esperadas para un elemento físico.

> Explique dos características de Java que no estaban presentes en C++ y cómo la Máquina Virtual
> Java ayuda en ello.
>> Java es un lenguaje interpretado y multiplataforma.
>> Java no se generan “fugas de memoria” (Memory leaks).
>> La JVM (Java Virtual Machine) permite la multiplataforma al disponer de una específica para cada
>> plataforma y como las aplicaciones Java son interpretadas por la JVM, se logra que cualquier aplicación
>> pueda correr en cualquier plataforma.
>> La JVM efectúa una recolección de basura (Garbage collection) en la que recupera los espacios de
>> memoria luego que éstos son inaccesibles para la aplicación

> IMPORTANTE
> Indique si el siguiente código tiene algún problema. Muestre los comandos que usaría para compilar
```Java
public class FirstSample {
 private course = "ELO329";
 public static void main(String[ ] args){
 System.out.println("Hello " + course);
 }
}
```
>
>>Sí tiene problema. El atributo course no tiene clase asociada (String) y es propio de una instancia de la
>>clase FirstSample y no puede ser accedido desde el método estático main. Hasta ese momento no se ha
>>creado ninguna instancia de FirstSample. Los métodos estáticos solo pueden acceder a atributos estáticos.
> 
>>Para compilar: $ javac FirstSample.java
> 
>>Para ejecutar: $ java FirstSample

>¿En qué situaciones se utiliza el bloque de inicialización estática? Un ejemplo de ello es:
```java
static {
Random generator = new Random();
nextId = generator.nextInt(10000);
}
```
>> Se ocupa para dar el valor inicial a variables estáticas y en especial cuando ello requiere la ejecución de varias instrucciones del lenguaje.

> IMPORTANTE
> Para el código: ClassA a = new ClassB();
> i) Indique qué relación debe existir entre ClassA y ClassB para que la instrucción sea válida.
>>La clase ClassB debe heredar de la clase ClassA en forma directa o indirecta a través de otras clases intermedias.
> ii) ¿Qué métodos y de qué clase puedo invocar usando la referencia a?
>> Con la referencia a se puede invocar cualquier método de la clase ClassA o de cualquiera de las
>> clases superiores de las cuales la clase ClassA hereda.
> iii) ¿Si un mismo método público aparece implementado en ambas clases, el código de qué clase se ejecuta?
>>Se ejecuta el código de la clase ClassB, excepto que el método sea privado en ClassA, en cuyo caso se ejecuta la implementación de ClassA.

> ¿Qué es la programación basada, dirigida o conducida por eventos? ¿Podrá su programa atender
> varios eventos si al generarse uno de ellos, el método invocado se queda en un loop infinito?
>> La programación conducida por eventos es aquella donde el programador accede a un mecanismo (creado
>> por él o el lenguaje) para registrar objetos asociados a eventos de interés. Luego ante la llegada de un
>> evento, ese mecanismo invoca el método que corresponda del objeto registrado para ese evento.
>> No. En un loop infinito no se pueden atender, en general, otros eventos (a menos que usemos hebras)

> Un amigo le hace entrega del archivo Final.jar que contiene todas las clases de una aplicación; sin
> embargo, no incluye el archivo manifiesto. Además le indica que la clase “Principal” contiene el
> método main. Muestre el comando que le permite ejecutar la aplicación.
> Suponga ahora que su jefe le pide que la aplicación se pueda ejecutar usando $java -jar Principal.jar
> Explique los pasos para generaría el archivo Principal.jar
```python
$java -cp Final.jar Principal
Una opción para generar el archivo Principal.jar se:
* Expandir todos los archivos .class presentes en Final.jar
  ($ jar xf Final.jar)
* Crear un archivo de manifiesto que especifique cuál es la clase que contiene el main.
  ($ echo “Main-class: Principal” > manifiesto.mf)
* Volver a generar ell archivo jar incluyendo el archivo de manifiesto.
  ($ jar cmf manifiesto.mf Principal.jar *.class )
  Nota: los comandos entre paréntesis no son pedidos en la pregunta.
```

>IMPORTANTE
> ¿Por qué al invocar un atributo no estático desde un método estático de la misma clase se genera un error de compilación?
>> Hay error de compilación porque los métodos estáticos pueden ser invocados sin existir previamente un
>> objeto creado con lo cual no existe aún ese atributo. Otra razón para prohibir este acceso es que aún
>> existiendo varios objetos previamente creados, la invocación de un método estático vía en nombre de la clase
>> no permite identificar el objeto para el cual su atributo debe ser usado.
>> Nota: no es del todo completa la respuesta si usted dice: No es posible porque desde un método estático sólo
>> se puede acceder a atributos estáticos

> Para las dos clases dadas implemente el método equals, el cual redefine el de la clase Object.
>> ![](/TheusZero/images/post/POO/48.png)
> Preguntar

> IMPORTANTE
> En un archivo Java podemos definir varias clases. ¿Por qué el compilador pide crear un archivo por cada
> clase cuando las clases llevan calificador de visibilidad public?
>> Las clases públicas pueden ser accedidas desde fuera del archivo que las contiene. Si ponemos dos clases públicas en un archivo, el compilador no podrá encontrar el archivo que contiene la descripción de una de
>> ellas cuando ésta es usada en otro archivo.

> En el contexto de programación gráfica en Java ¿cuál es la diferencia entre el modelo y la vista? Dé un
> ejemplo en el cual un mismo modelo puede estar asociado a más de una vista.
>> El modelo es el conjunto de atributos que representan a un objeto en memoria, mientras que la vista es la
>> representación visual de las características contenidas en el modelo.
>> Ej: Un termómetro es modelado a través de su atributo “temperatura”, sin embargo visualmente se puede ver
>> como un termómetro de mercurio o un termómetro digital (u otros tipos de termómetros).

> IMPORTANTE
> Considere las siguientes clases ya definidas:
> ![](/TheusZero/images/post/POO/49.png)
> ¿En qué contexto se justificaría la creación de la super clase “Animales”? ¿En qué contexto no se
> justifica? Dé un ejemplo de cada caso (no se pide código, sólo explicar cada ejemplo.
>> Una de las ventajas de crear súper clases es evitar la duplicidad de código y favorecer el mantenimiento. Sin
>> embargo, en este caso, si bien, se podría argumentar que ambas clases tienen en común que son animales, en
>> cuanto a su implementación no tienen elementos en común.
>> Considerando esto como base, no se justificaría la creación de una clase animales si estas clases
>> efectivamente son utilizadas en contextos dentro del código distintos.
>> En caso de que sí sean utilizadas en un mismo contexto dentro del código y que además sea necesaria la
>> agrupación de estas clases, entonces sí se justificaría la creación de la clase padre animales.
>> 
>> Algunos ejs. de creación clase animales:
>> • Se necesita agrupar tanto perros como gatos en un arreglo de animales
>> • Existe un método que recibe animales como entrada, pudiendo ser tanto perros como gatos
>> 
>> Alugnos ejs. de no creación de clase animales:
>> • Existen métodos separados para recibir gatos y perros
>> • No sea necesaria ningún tipo de agrupación de animales en el programa

> En el contexto de programación genérica, cree un método estático insertar(pos, a, arr) que inserte un
> elemento a en la posición pos de un arreglo java arr, siempre y cuando pos sea una posición válida. Si
> la posición es válida, luego de insertar el elemento se retorna true, en caso contrario, se retorna false.
> El arreglo arr puede contener elementos de cualquier clase. Solo debe escribir el código asociado al
> método, no es necesario escribir la definición de clase.
> ```java
> Ej. de uso: /* Uso: GenericClass.insertar(pos,a,arr); */
> Integer[] arr = {1,2,3,4,5,6,7,8}; // arr = [1, 2, 3, 4, 5, 6, 7, 8]
> int a = 10;
> System.out.print(GenericClass.insertar( 0, a, arr)); // arr = [10, 2, 3, 4, 5, 6, 7, 8], imprime true
> System.out.print(GenericClass.insertar(15, a, arr)); // arr = [10, 2, 3, 4, 5, 6, 7, 8], imprime false
> ```
>> ```java
>> public static boolean insertar(int pos, Object a, Object[] arr){
>> if(pos >= 0 && pos < arr.length){
>> arr[pos] = a;
>> return true;
>> }
>> return false;
>> }
>> ```

> IMPORTANTE
> ¿Puede una clase abstracta heredar de otra clase abstracta? ¿Puede una interfaz implementar otra
> interfaz? Justifique.
>> Una clase abstracta SÍ puede heredar de otra clase abstracta. Una clase abstracta es una clase cuya
>> única diferencia con el resto es que nunca será instanciada y que tiene al menos un método no
>> implementado. Respetando esta definición, cumple con las mismas características de cualquier clase Java,
>> por lo que no hay ninguna restricción para que se cumpla herencia entre ellas.
>
>> Una interfaz NO puede implementar otra interfaz. Una interfaz es la descripción de uno o más métodos
>> que alguna clase puede ofrecer. Utilizar una interfaz implica la implementación de la misma, y por tanto, de
>> los métodos definidos en ella. Una interfaz no sería capaz de implementar los métodos que ofrezca otra
>> interfaz (por definición, una interfaz no tiene ningún método implementado), por lo que es incompatible
>> implementar una en la otra.

> Desarrolle el programa DragMe.java. Cuando se ejecute este programa, aparecerá una
> ventana con un elemento gráfico de tipo rectángulo en la esquina superior izquierda de la misma.
> Este rectángulo puede ser arrastrado libremente usando el mouse.
> Para arrastrarlo, se debe hacer click con el botón del mouse en cualquier punto interior del rectángulo y, sin
> soltarlo, mover el mouse con el rectángulo a la nueva posición deseada para luego soltar el botón del mouse.
> La posición del centro del rectángulo deberá coincidir con la última posición del mouse antes de soltar el
> botón.
> El programa finaliza al cerrar la ventana principal.
> Características del programa:
> - La ventana tendrá dimensiones de 300 pixeles de ancho y 200 pixeles de alto
> - El rectángulo tendrá dimensiones de 100 pixeles de ancho y 30 pixeles de alto
>> [RESPUESTA](http://profesores.elo.utfsm.cl/~agv/elo329/1s17/grades/C1_1s17_Sol.pdf)

> Importante
> Ejercicio static y final
> ![](/TheusZero/images/post/POO/50.png)

> IMPORTANTE
> Ejercicio equals
> ![](/TheusZero/images/post/POO/51.png)

>> EJERCICIO MUY IMPORTANTE
> Como parte del código de un software de manejo de gestión de empleados, se han definido las clases
> Employee y Manager, siendo esta última una extensión de la clase Employee. Esto permite contar con
> una instancia que además de ser Employee, se le puede asignar y solicitar funciones propias de un cargo
> de gerencia, como ejecutar un control de proyectos a través del método projectControl().> 
>
>  ¿Cuál de las siguientes asignaciones son correctas? Comente
```Java
 Employee e = New Manager();
Manager m = New Employee();
```
>> La primera asignación es correcta. Es posible asignar una instancia de tipo Manager a un objeto Employee,
>> ya que un Manager puede realizar todo lo que un Employee realiza (Manager es una extensión de
>> Employee).
>>
>> La segunda asignación no es correcta. No es posible asignar una instancia de Employee a un objeto de tipo
>> Manager, ya que es posible que se le exijan tareas específicas de Manager, para las que Employee no
>> cuenta con una implementación

> Se cuenta con una lista dinámica de Employee.
> ```java
> ArrayList<Employee> e = New ArrayList<Employee>;
> e.add((Employee) new Manager(“buenaJefa”)); // único elemento del arrayList.
> ```
> // Complete el código para invocar el método projectControl del mánager ingresado.
>> Employee tmpE = e.get(0); // Se accede al empleado
>> if (tmpE instanceof Manager) { // Nos aseguramos de que sea de tipo Manager
>> Manager m = (Manager) tmpE; // Casteamos Employee a Manager
>> m.projectControl(); // Ahora podemos acceder a los métodos de Manager
>> }

>> Importante
> El uso de métodos que arrojan excepciones requiere que éstas se manejen.
> 
> Comente cuál es la función de los bloques utilizados al capturar excepciones: try, catch, y finally
>
> try { // Bloque try
>> Ejecución de código de forma segura. Si algo falla, se generará un evento de
>> error que puede ser capturado con catch.
> 
> } catch (e-clase1 e ) { // Bloque catch
>> El bloque catch permite realizar una serie de instrucciones específicas para
>> abordar una situación de error. Para cada tipo de error, existirá alguna clase
>> exception (en este bloque sería e-clase1), que incluye los errores que se han de
>> manejar, por ejemplo IOException para errores relacionados al uso de
>> entradas/salidas..
> 
>> } catch (e-clase2 e ) { // Bloque catch
>> Aquí se manejarían excepciones de tipo e-clase2.
>> } …
> 
>> finally { // Bloque finally
>> Permite ejecutar instrucciones al finalizar el bloque try, luego de haber generado
>> y respondido a alguna (o ninguna) excepción.
>> }
> ![](/TheusZero/images/post/POO/52.png)

> ¿Qué significa relanzar una excepción?
>> La sección de código (método) que generó la excepción tiene la posibilidad de manejarla o relanzarla. Al
>> relanzarla, se deberá encargar de manejar la excepción la sección de código que llamó al método donde se
>> generó la excepción. Eso permite entregar la responsabilidad de manejar los problemas a un nivel de
>> jerarquía superior, de forma más general, en comparación a sólo manejarlo en la posición donde se generó el
>> problema. La excepción a ser manejada puede subir hasta el mismo método main.
>> Para esto, el método debe indicar ```throws exceptionType``` en su declaración, por ejemplo:
>> 
>> ```public static void readFile() throws IOException { … }```

> Importante
> Liste los calificadores de visibilidad (= modificador de acceso) de métodos y atributos. Dejando fuera el
> más restrictivo y el menos restrictivo, explique el uso de los restantes.
>> Modificadores de acceso: private, protected, public y la omisión del calificador de visibilidad.
>> private y public son el más y el menos restrictivo respectivamente.
>> protected: se usa cuando se desea dar acceso a una clase heredada de aquella que define el método o
>> atributo protected o bien alguna clase del mismo paquete.
>> Omisión del modificador de acceso: corresponde a acceso permitido a todas las clases que forman parte de
>> un mismo paquete

> Para las dos clases dadas implemente el método clone, el cual redefine el de la clase Object.
>> ![](/TheusZero/images/post/POO/53.png)

> [ejercicios programacion](http://profesores.elo.utfsm.cl/~agv/elo329/1s18/grades/C1_1s18_Sol.pdf)

>> Importante
> En el contexto de la Programación Orientada a Objetos defina: clase, objeto, atributo, constructor
>> Clase: es la definición de las características comunes a un conjunto de objetos. Las característica comunes
>> son los atributos a considerar y el comportamiento de esos objetos.
>> Objeto: en POO un objeto es la representación en un programa de un objeto real. Esta representación define
>> un nombre, un estado y un comportamiento para el objeto.
>> Un objeto es una instancia de una Clase.
>> Atributo: es una un dato que permite almacenar parte del estado de un objeto. El conjunto de atributos de un
>> objeto almacenan su estado.
>> Constructor: Código que define el valor inicial de un objeto al ser creado.

> IMPORTANTE PREGUNTAR
> ![](/TheusZero/images/post/POO/54.png)

>> IMPORTANTE PREGUNTAR
> Implemente el método equals de la clase B.
> ![](/TheusZero/images/post/POO/55.png)

>> IMPORTANTE
> Se tiene la definición de clases anidadas como se muestra a la izquierda. Ponga a la derecha el código para
> crear el objeto de nombre “anidado” como instancia de la clase AnidadaEstatica y el objeto “interno” como instancia de la clase Interna.
```Java
Externa.AnidadaEstatica anidado = new Externa.AnidadaEstatica();
Externa externo = new Externa();
Externa.Interna interno = externo.new Interna();
```
> ![](/TheusZero/images/post/POO/56.png)

>> Importante
> Considere que existen las clases Silla y Estante las cuales derivan de la clase abstracta Mueble.
> Suponiendo que existen los constructores por defecto, determine si las siguientes secciones de código son correctas o no y explique el motivo.
>> ![](/TheusZero/images/post/POO/57.png)

>Si bien todas las excepciones deben retornar elementos subclases de Throwable, java prohíbe crear
>subclases directas de ésta. Comente si es posible crear excepciones propias, y si es así, cómo se resuelve el
>no poder extender Throwable.
>> Sí es posible crear excepciones propias.
>> La situación se resuelve porque existe una clase (Exception), que deriva de Throwable, de la cual sí es
>> posible crear subclases directas.

> Usted cuenta con la lista dinámica pers, la cual contiene objetos tipo Personas y Ayudantes (esta última
> extiende de Personas). Defina el método cuentaAyudantes, tal que retorne la cantidad de ayudantes
> existentes en la lista (responda en el espacio de la derecha).
>> ![](/TheusZero/images/post/POO/58.png)

> En relación a los archivos Java Archive (jar):
>> h.1) Comente 2 ventajas de su uso.
>> Se facilita el transporte del código. En lugar de copiar o enviar múltiples archivos .class, imágenes,
>> audios, etc. se copia o envía solo un archivo.
>
>> La ejecución se simplifica pues se puede configurar su ejecución con doble click sobre ellos.
>> h.2) Describa la funcionalidad del documento de manifiesto.
>> El documento manifiesto permite indicar a la máquina virtual qué clase dentro de un jar contiene el
>> método main de inicio.

> [ejercicios](http://profesores.elo.utfsm.cl/~agv/elo329/1s19/grades/C1_1s19_Sol.pdf)

>  ¿Qué diferencia existe entre el operador == y el uso del método equals(…)?
> Un estudiante revisa una clase y no encuentra en ella la implementación del método equals(…) ¿por qué
> no se produce error al invocarlo sobre una instancia de esa clase?
>> Diferencia entre == y método equals(…): El primero compara dos referencias, será verdadero si dos
>> nombres (o referencias a objetos) se refieren al mismo objeto. El método equals(…) compara dos objetos por igualdad.
>> No se produce error pues todo objeto hereda de la clase Object aunque no lo explicite. La clase Object
>> implementa el método equals(…) por ello no hay error al invocarlo.

> IMPORTANTE
>> ![](/TheusZero/images/post/POO/59.png)

> En clases vimos que podemos decir “un cuadrado es un rectángulo de lados iguales”. Mencione otro
> ejemplo de dos clases donde esté presente la relación es-un pero no se cumpla el principio de sustitución.
> Explique por qué no se cumple en principio de substitución.
>> Múltiples respuestas son válidas aquí.
>> Alguien pudo decir: un punto es un círculo de radio cero.
>> Hay relación es-un pero no se cumple el principio de substitución pues si una instancia de esta clase Punto
>> acude por sustitución en lugar de un círculo, cuando el usuario de círculo cambie su radio, el punto no podrá
>> hacerlo. Así se demuestra que un círculo no puede ser sustituido por una instancia de esa clase Punto.

> Los teléfonos celulares pueden hacer y recibir llamadas telefónicas. Podemos decir que un teléfono celular
> es un teléfono. Como se pueden tomar fotos, podemos también decir que un teléfono celular es una
> cámaras fotográficas. Considerando estos comportamientos ¿Qué declaraciones pondría usted en los
> archivos Telefono.java, Camara.java, y TelefonoCelular.java, ? Omita los métodos y atributos de cada clase.
> Interesa la primera línea de cada clase
>> Respuesta:
```Java
public class TelefonoCelular extends Telefono implements Carama { ... }
public interface Camara {....}
public class Telefono {…. }
```

> Considere la siguiente clase:
> ![](/TheusZero/images/post/POO/60.png)
> Modifíquela para que permita realizar una copia profunda de una instancia de A.
>> Basta con implementar la interfaz Cloneable y el método clone. Al ser los atributos x e y de tipos primitivos,
>> NO es necesario hacer copia profunda.
```Java
class A implements Cloneable{
 private int x,y;

 public A(int x, int y){
 this.x = x;
 this.y = y;
 }
 public Object clone(){
 A a = (A) super.clone();
 return a;
 }
}
```

> Considere el código de la siguiente interfaz
> ![](/TheusZero/images/post/POO/61.png)
> Indique si es posible utilizar esta interfaz en una expresión lambda. Si es posible, dé un ejemplo. En caso contrario, justifique.
>> No es posible. Para que se pueda utilizar una expresión lambda sobre una interfaz, es necesario que esta
>> defina un solo método. Interfaces con dos o más métodos no pueden ser utilizados a través de expresiones
>> lambda.

> Considere el siguiente bloque de código try-catch
```Java
try{
 f(); // Genera Excepcion1
 g(); // Genera Excepcion2
} catch(Excepcion1 e1){
 System.out.println(“Excepcion 1”);
} catch(Excepcion2 e2){
 System.out.println(“Excepcion 2”);
}
```
> Indique y justifique las salidas por pantalla cuando:
> • Al ejecutar el código, solo el método f() producirá una excepción.
> • Al ejecutar el código, solo el método g() producirá una excepción.
> • Al ejecutar el código, ambos métodos f() y g() producirán una excepción.
>> System.out.println(“Excepcion 1”);
> 
>> System.out.println(“Excepcion 2”);
> 
>> System.out.println(“Excepcion 1”);
> 
>> En el último caso, cuando se produce una excepción, esta se lanza inmediatamente, por lo que el código de
>> la función g(), a pesar de que producirá una excepción, NUNCA alcanza a ejecutarse. Por lo que solo se
>> muestra el mensaje producido por la excepción de f().

> Para el desarrollo de una aplicación Android, necesita acceder a la lista de contactos del usuario. Indique
> qué clase provista por Android debe utilizar para esta tarea y por qué.
>> Es necesario utilizar la clase Intent, la cual se encarga de indicarle a Android que se desea acceder a la lista
>> de contactos. De esta manera, Android manejará internamente cuál es la aplicación que responderá a la
>> petición.
 
> [ejercicios](http://profesores.elo.utfsm.cl/~agv/elo329/1s20/grades/C1_1s20_Sol.pdf) 