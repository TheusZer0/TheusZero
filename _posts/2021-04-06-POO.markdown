---
layout: post
title: "POO"
subtitle: 'POO'
date: 2021-04-02 12:00:00
author: "TheusZero"
header-img: "images/post/PythonAutoayuda/solarized-wallpaper-python.png"
catalog: true
comments: true
tags:
    - Programacion
    - Python
    - USM
    - Tareas
    - Java
    - C++
---

## Programacion en java

#### arrays Unidimensionales
> ![](/TheusZero/images/post/POO/6.png)
> ![](/TheusZero/images/post/POO/7.png)
> ![](/TheusZero/images/post/POO/8.png)

#### arrays bidimensionales o de muchas dimensiones
> ![](/TheusZero/images/post/POO/10.png)
> ![](/TheusZero/images/post/POO/11.png)
> ![](/TheusZero/images/post/POO/12.png)

#### for each
> ![](/TheusZero/images/post/POO/9.png)

## Clases, objetos y comportamiento

> ![](/TheusZero/images/post/POO/13.png)

> Clases, forma generalizada (idea) para hablar de objetos ya que estas definen las caracterizticas generales de una clase objeto.
>> objeto Patricio, clase Persona

Estas clases tienen **atributos** que son generales (RUT, EDAD, etc) y tambien tenemos comportamientos llamados **metodos**, (caminar, comer, respirar, etc).
Estos estaran definidos desde la clase.

> por lo que, las clases son un conjunto de objetos con caracteristicas similares
> ![](/TheusZero/images/post/POO/14.png)

> Clase: es la definición de las características comunes a un conjunto de objetos. Las característica comunes son los atributos a considerar y el comportamiento de esos objetos.

> Objeto: en POO un objeto es la representación en un programa de un objeto real. Esta representación define un nombre, un estado y un comportamiento para el objeto. Un objeto es una instancia de una Clase.

> Atributo: es una un dato que permite almacenar parte del estado de un objeto. El conjunto de atributos de un objeto almacenan su estado.

> Constructor: Código que define el valor inicial de un objeto al ser creado.

#### creacion de clases y objetos

> ![](/TheusZero/images/post/POO/15.png)

> ![](/TheusZero/images/post/POO/16.png)

> ![](/TheusZero/images/post/POO/17.png)

> ![](/TheusZero/images/post/POO/18.png)

> ![](/TheusZero/images/post/POO/19.png)

> ![](/TheusZero/images/post/POO/20.png)


#### Constructores

> ![](/TheusZero/images/post/POO/21.png)
>> O bien tambien puede quedar: 
>> ![](/TheusZero/images/post/POO/22.png)
> ![](/TheusZero/images/post/POO/23.png)

#### Miembros estáticos de una clase

> si se antepone static, la variable pasa a ser para toda la clase, es decir, que si hacemos un cambio, este repercute y cambia todas las variables, por ejemplo
>> ![](/TheusZero/images/post/POO/26.png)

> ademas para la creacion de clase, esto pasa:
>> ![](/TheusZero/images/post/POO/27.png)

#### metodos getter/setter

> ![](/TheusZero/images/post/POO/24.png)

#### Jerarquias de Clases: Herencia

> la clase estudiante y profesor heredan de la clase persona atributos, por lo que hay una jerarquia que define a persona como un general del cual heredan atributos otras clases
> ![](/TheusZero/images/post/POO/2.png)
> ![](/TheusZero/images/post/POO/3.png)
> ![](/TheusZero/images/post/POO/4.png)
> ![](/TheusZero/images/post/POO/5.png)

#### clases y metodos abstractos:

> Clase abstracta
>> Se utilizan solo como super clases (clases padres)
>
>> No se pueden instanciar objetos, no puedes crear objetos
>
>> Sirve para proporcionar una clase padre apropiada a partir de la cual heredan otras clases, siendo estas otras clases hijas las que extenderan el funcionamiento de los metodos, es decir, que seran quienes expliquen el funcionamiento en base a codigo. La clase Padre solo dice que el metodo existe, pero no como es que sera llevado a cabo.
>
>> ![](/TheusZero/images/post/POO/30.png)
>> ![](/TheusZero/images/post/POO/31.png)
>> ![](/TheusZero/images/post/POO/32.png)
>> ![](/TheusZero/images/post/POO/33.png)
>> ![](/TheusZero/images/post/POO/34.png)
>> ![](/TheusZero/images/post/POO/35.png)
>> ![](/TheusZero/images/post/POO/36.png)





## Preguntas Certamenes

> Explique por qué se recomienda reemplazar los “tabs” por espacios para indentar código fuente.
>> Así la indentación se visualiza de igual forma en distintos editores y sus versiones impresas. El
>> tamaño de cada tab es definido por el entorno, luego lo que se ve indentado en uno puede no
>> estarlo en otro.

> Nombre y explique tres características que comparten los lenguajes orientados a objetos.
>> Herencia: la posibilidad de definir una clase o tipo de objeto a partir de la definición de otra.
>
>> Subtipo: la posibilidad de usar instancias de clases derivadas donde se espera una instancia de la
>> clase base.
>
>> Ligado dinámico: el código invocado ante un llamado es definido en tiempo de ejecución
>> permitiendo así que el resultado dependa del objeto específico que recibe el llamado. En conjunto
>> con subtipo, permite generar códigos reusables

> La clase Timer está definida en java.util.Timer y en javax.swing.Timer. ¿Qué definición de import debe
> hacer en su código para usar Timer del paquete java.util?
>> import java.util.Timer;
> ¿Cómo lo hace si además de esta clase, en su programa usted requiere crear instancias de Timer el paquete javax.swing?
>> Como antes al inicio uso:
>> import java.util.Timer;
>> Luego cada vez que desee usar una instancia de Timer de javax.swing, uso la versión completa
>> para la clase, esto es:
>> javaxswing.Timer miTiner; /* así cada vez que requiero referirme a instancias de esta clase*/

> Alguien dice: “Sea emp una instancia de Empleado, al asignar emp=null; en todos los casos el espacio de
> memoria referenciado por emp será recolectado por el recolector de basura de java. ¿Está de cuerdo? Explique.
>> No, debido a que podemos tener más de un nombre para un objeto; es decir, pude haber más de
>> una referencia apuntando a un objeto. El recolector de basura sólo recupera el espacio de memoria
>> cuando no hay referencias a ese espacio

> ![](/TheusZero/images/post/POO/25.png)

> Alguien dice: “Si en un archivo tenemos definidas dos clases A y B, sólo una de ellas puede contener el
> método public static void main (String argv[]) {….. }” ¿Está usted de acuerdo? Justifique.
>> No estoy de acuerdo. El método main puede estar en más de una clase. Aquella que use al correr el
>> programa definirá qué método main es usado.

> Alguien dice: Si B hereda de A y hemos declarado: ```B b;``` entonces será un error de compilación si en alguna parte del programa hacemos: ```A a= (A) b;``` ¿Está usted de acuerdo? Justifique.
>>No estoy de acuerdo, pues eso es perfectamente posible. b hereda de A, luego por subtipo puede
>>tomar el lugar donde se espera una instancia de A. Incluso es válido poner: ```B b2 = (B) a;``` debido a que a bien podría ser referencia a instancias de B, en cuyo caso el casteo es posible
>>> PREGUNTAR, que pasaria si B tiene variables que A no tiene? donde quedan?

> ![](/TheusZero/images/post/POO/28.png)
> ```AQUI IRA MI CODIGO```

>> Ejercicio Vectores
> ![](/TheusZero/images/post/POO/29.png)

> La clase C hereda de B, y B hereda de A. A posee un método protegido getPeso(), el cual no es redefinido
> por B. ¿Es posible redefinir este método en C?
>> Sí. Los métodos protegidos dan visibilidad a las clases derivadas.
> Si su respuesta es afirmativa, ¿cómo podemos llamar la implementación de A de getPeso() desde algún
>método de C?
>> La invocación la haríamos con super.getPeso();
>> Esto funciona pues la versión de getPeso() visible en la clase B es justamente aquella definida en A

> Al redefinir un método en una subclase, ¿es posible retornar un objeto de distinta clase al retornado en el método de la super clase? Explique.
>> Sí es posible. Se debe cumplir que la clase del objeto retornado por la redefinición debe ser subclase de la clase del objeto retornado por el método redefinido.
>>> PREGUNTAR

> ¿Cuándo se usa la sentencia import javax.swing.JOptionPane;? ¿Podríamos omitir este “import”?
>> La sentencia import javax.swing.JOptionPane; se usa cuando deseamos crear instancias de la clase JOptionPane, como en:
>> ```JOptionPane obj=new JOptionPane();``` Sí se puede omitir, pero cada vez que deseemos crear una instancia de esa clase debemos usar la especificación completa como en:
>> ```javax.swing.JOptionPane obj=new javax.swing.JOptionPane();```

> Alguien dice: un cuadrado es un rectángulo de lados iguales. Al ver la forma es-un,
> piensa en herencia. Dé dos razones por las que no es bueno definir la clase Cuadrado como heredando de Rectángulo.
>> Al hacerlo estaríamos usando más memoria de la necesaria para almacenar cuadrados.
>
>> Habría problemas al aplicar el principio de sustitución. Si un método espera un rectángulo para crear la portada de un libro, el método no podrá definir un alto distinto de un ancho si el objeto fuera instancia de cuadrado.

> La expresión “hola”==”hola”, ¿es verdadera o falsa? Explique.
>> Es verdadera. Los strings son objetos en Java, pero por tratarse de strings literales, es
>> secuencia de caracteres entre “”, éstos quedan internos en la clase String y el
>> compilador asocia una única referencia a iguales contenidos

> Si las técnicas de orientación a objeto pueden dar solución a los mismos problemas que
> los lenguajes no orientados a objetos, ¿Dé dos razones para su uso común en los lenguajes actuales?
>> La orientación a objeto facilita la reutilización de código.
> 
>> La orientación a objeto facilita el trabajo en equipo

> Juan instaló el JDK de java, Pedro instaló JRE. Mencione dos cosas que puede hacer Juan pero no Pedro.
>> Juan puede compilar programas con javac.
> 
>> Juan puede extraer la documentación de un programa con javadoc

>> Pregunta Importante
> La clase B es derivada de A. En B redefinimos el método público getEdad() de A.
> ¿Cómo podemos invocar getEdad() implementado por A desde otro método en B?
> ¿Cómo desde este método en B podemos invocar getEdad() implementado en B?
>> Para invocar implementación de A, en el método de B pongo: ```super.getEdad();``` // con esto invocamos la implementación de A.
>
>> Para invocar implementación de B, pongo: ```getEdad();``` // Así invocamos la implementación en B desde un método de B.

> ¿Es posible impedir que un método sea redefinido en una clase derivada? Justifique.
> Sí es posible, basta poner agregar el calificador final al método, como en: ```class A { public final int getEdad() {....} ....}```

> a) Para un juego se le pide crear dados de N caras. Estos dados pueden tomar valores dentro del
> conjunto {1,2,3,..., N}. Cree la clase Dado. Ésta permite definir el número de caras en su
> constructor. Si no se señala, se asume 6 caras. Estos dados deben permitir ser lanzados y en
> cualquier momento se puede consultar el valor del último lanzamiento del dado.
> b) Desarrolle Juego, una aplicación Java que usa la clase definida en a) y muestra una interfaz
> gráfica con un botón, el cual lanza un dado al ser presionado, y un área para mostrar el resultado
> del lanzamiento. El número de caras es ingresado por consola vía un argumento en la línea de
> ejecución de esta aplicación.
> c) Señale qué cambio debe hacer a su clase Dado para implementar la interfaz Comparable
> basado en el último lanzamiento de los dados.

> ¿La Programación Orientada a Objeto es un tipo de programación Imperativa o Declarativa? Explique.
>> La Programación Orientada a Objetos (POO) es Imperativa. En la programación Imperativa el
>> programa señala cómo se debe llevar la computación. Éste es el caso de la POO.
>> (Nota: En la programación declarativa se indica qué se debe hacer y las condiciones en las cuales se
>> hace, pero no el cómo se debe hacer)

> Defina con sus palabras los siguientes términos: instancia, clase heredada, principio de sustitución.
>> Instancia es un objeto o ente específico que cumple con la descripción hecha en una clase.
>> Clase heredada: es una clase definida a partir de otra más general llamada clase base, padre o
>> superclase. Una clase heredada reutiliza el código y extiende la clase base haciéndola más específica.
>> Principio de sustitución: es la propiedad de los objetos de poder tomar el lugar donde se esperaba uno de
>> categoría más general. Se da entre instancias de clases derivadas donde se espera una de la base o de
>> jerarquía superior. También se da entre instancias de una clases que toman el lugar donde se espera un
>> objeto que cumpla una interfaz

> ¿Qué hace posible que un mismo byte-code pueda correr en máquinas de distintas arquitecturas y distintos sistemas operativos?
>> Esto se logra por la existencia de una Máquina Virtual Java (JVM) para cada par (arquitectura, sistema operativo).

> Mencione dos usos de la palabra reservada “final”.
>> “final” lo usamos para identificar que un atributo no puede cambiar su valor una vez asignado en su constructor. “final” también lo usamos para indicar que un método no puede ser redefinido en clases derivadas

> ¿Por qué se dice que la relación es-un entre clases es una condición necesaria pero no suficiente para
> identificar relación de herencia entre clases? ¿Qué condición adicional se debe cumplir para que identificar herencia?
>> Es una condición necesaria pues la relación de herencia sólo se da cuando existe la relación es-un entre
>> una instancia de la clase heredada y una instancia de la clase base. No es suficiente pues existen casos
>> de relación es-un pero donde no hay herencia. Un ejemplo de esto es: un cuadrado es un rectángulo de
>> lados iguales. Existe relación es-un pero no herencia.
>> La condición adicional es cumplir el principio de sustitución. En el ejemplo previo el comportamiento de
>> un rectángulo nos permite ensancharlo hasta que su ancho sea, por ejemplo, el doble de su alto. Si en su
>> lugar usáramos un cuadrado, este comportamiento no es posible.























>  ¿Qué diferencia existe entre el operador == y el uso del método equals(…)?
> Un estudiante revisa una clase y no encuentra en ella la implementación del método equals(…) ¿por qué
> no se produce error al invocarlo sobre una instancia de esa clase?
>> Diferencia entre == y método equals(…): El primero compara dos referencias, será verdadero si dos
>> nombres (o referencias a objetos) se refieren al mismo objeto. El método equals(…) compara dos objetos por igualdad.
>> No se produce error pues todo objeto hereda de la clase Object aunque no lo explicite. La clase Object
>> implementa el método equals(…) por ello no hay error al invocarlo.