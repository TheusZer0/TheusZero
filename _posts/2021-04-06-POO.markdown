---
layout: post
title: "POO"
subtitle: 'POO'
date: 2021-04-02 12:00:00
author: "TheusZero"
header-img: "images/post/PythonAutoayuda/solarized-wallpaper-python.png"
catalog: true
comments: true
tags:
    - Programacion
    - Python
    - USM
    - Tareas
    - Java
    - C++
---

## Programacion en java

#### arrays Unidimensionales
> ![](/TheusZero/images/post/POO/6.png)
> ![](/TheusZero/images/post/POO/7.png)
> ![](/TheusZero/images/post/POO/8.png)

#### arrays bidimensionales o de muchas dimensiones
> ![](/TheusZero/images/post/POO/10.png)
> ![](/TheusZero/images/post/POO/11.png)
> ![](/TheusZero/images/post/POO/12.png)

#### for each
> ![](/TheusZero/images/post/POO/9.png)

## Clases, objetos y comportamiento

> ![](/TheusZero/images/post/POO/13.png)

> Clases, forma generalizada (idea) para hablar de objetos ya que estas definen las caracterizticas generales de una clase objeto.
>> objeto Patricio, clase Persona

Estas clases tienen **atributos** que son generales (RUT, EDAD, etc) y tambien tenemos comportamientos llamados **metodos**, (caminar, comer, respirar, etc).
Estos estaran definidos desde la clase.

> por lo que, las clases son un conjunto de objetos con caracteristicas similares
> ![](/TheusZero/images/post/POO/14.png)

> Clase: es la definición de las características comunes a un conjunto de objetos. Las característica comunes son los atributos a considerar y el comportamiento de esos objetos.

> Objeto: en POO un objeto es la representación en un programa de un objeto real. Esta representación define un nombre, un estado y un comportamiento para el objeto. Un objeto es una instancia de una Clase.

> Atributo: es una un dato que permite almacenar parte del estado de un objeto. El conjunto de atributos de un objeto almacenan su estado.

> Constructor: Código que define el valor inicial de un objeto al ser creado.

#### creacion de clases y objetos

> ![](/TheusZero/images/post/POO/15.png)

> ![](/TheusZero/images/post/POO/16.png)

> ![](/TheusZero/images/post/POO/17.png)

> ![](/TheusZero/images/post/POO/18.png)

> ![](/TheusZero/images/post/POO/19.png)

> ![](/TheusZero/images/post/POO/20.png)


#### Constructores

> ![](/TheusZero/images/post/POO/21.png)
>> O bien tambien puede quedar: 
>> ![](/TheusZero/images/post/POO/22.png)
> ![](/TheusZero/images/post/POO/23.png)

#### Miembros estáticos de una clase

> si se antepone static, la variable pasa a ser para toda la clase, es decir, que si hacemos un cambio, este repercute y cambia todas las variables, por ejemplo
>> ![](/TheusZero/images/post/POO/26.png)

> ademas para la creacion de clase, esto pasa:
>> ![](/TheusZero/images/post/POO/27.png)

#### metodos getter/setter

> ![](/TheusZero/images/post/POO/24.png)

#### Jerarquias de Clases: Herencia

> la clase estudiante y profesor heredan de la clase persona atributos, por lo que hay una jerarquia que define a persona como un general del cual heredan atributos otras clases
> ![](/TheusZero/images/post/POO/2.png)
> ![](/TheusZero/images/post/POO/3.png)
> ![](/TheusZero/images/post/POO/4.png)
> ![](/TheusZero/images/post/POO/5.png)

## Preguntas Certamenes

> Explique por qué se recomienda reemplazar los “tabs” por espacios para indentar código fuente.
>> Así la indentación se visualiza de igual forma en distintos editores y sus versiones impresas. El
>> tamaño de cada tab es definido por el entorno, luego lo que se ve indentado en uno puede no
>> estarlo en otro.

> Nombre y explique tres características que comparten los lenguajes orientados a objetos.
>> Herencia: la posibilidad de definir una clase o tipo de objeto a partir de la definición de otra.
>
>> Subtipo: la posibilidad de usar instancias de clases derivadas donde se espera una instancia de la
>> clase base.
>
>> Ligado dinámico: el código invocado ante un llamado es definido en tiempo de ejecución
>> permitiendo así que el resultado dependa del objeto específico que recibe el llamado. En conjunto
>> con subtipo, permite generar códigos reusables

> La clase Timer está definida en java.util.Timer y en javax.swing.Timer. ¿Qué definición de import debe
> hacer en su código para usar Timer del paquete java.util?
>> import java.util.Timer;
> ¿Cómo lo hace si además de esta clase, en su programa usted requiere crear instancias de Timer el paquete
> javax.swing?
>> Como antes al inicio uso:
>> import java.util.Timer;
>> Luego cada vez que desee usar una instancia de Timer de javax.swing, uso la versión completa
>> para la clase, esto es:
>> javaxswing.Timer miTiner; /* así cada vez que requiero referirme a instancias de esta clase*/

> Alguien dice: “Sea emp una instancia de Empleado, al asignar emp=null; en todos los casos el espacio de
> memoria referenciado por emp será recolectado por el recolector de basura de java. ¿Está de cuerdo? Explique.
>> No, debido a que podemos tener más de un nombre para un objeto; es decir, pude haber más de
>> una referencia apuntando a un objeto. El recolector de basura sólo recupera el espacio de memoria
>> cuando no hay referencias a ese espacio

> ![](/TheusZero/images/post/POO/25.png)

> Alguien dice: “Si en un archivo tenemos definidas dos clases A y B, sólo una de ellas puede contener el
> método public static void main (String argv[]) {….. }” ¿Está usted de acuerdo? Justifique.
>> No estoy de acuerdo. El método main puede estar en más de una clase. Aquella que use al correr el
>> programa definirá qué método main es usado.

> Alguien dice: Si B hereda de A y hemos declarado: ```B b;``` entonces será un error de compilación si en alguna parte del programa hacemos: ```A a= (A) b;``` ¿Está usted de acuerdo? Justifique.
>>No estoy de acuerdo, pues eso es perfectamente posible. b hereda de A, luego por subtipo puede
>>tomar el lugar donde se espera una instancia de A. Incluso es válido poner: ```B b2 = (B) a;``` debido a que a bien podría ser referencia a instancias de B, en cuyo caso el casteo es posible
>>> PREGUNTAR, que pasaria si B tiene variables que A no tiene? donde quedan?

> ![](/TheusZero/images/post/POO/28.png)
> ```AQUI IRA MI CODIGO```

>> Ejercicio Vectores
> ![](/TheusZero/images/post/POO/29.png)

> La clase C hereda de B, y B hereda de A. A posee un método protegido getPeso(), el cual no es redefinido
> por B. ¿Es posible redefinir este método en C?
>> Sí. Los métodos protegidos dan visibilidad a las clases derivadas.
> Si su respuesta es afirmativa, ¿cómo podemos llamar la implementación de A de getPeso() desde algún
>método de C?
>> La invocación la haríamos con super.getPeso();
>> Esto funciona pues la versión de getPeso() visible en la clase B es justamente aquella definida en A

> Al redefinir un método en una subclase, ¿es posible retornar un objeto de distinta clase al retornado en el método de la super clase? Explique.
>> Sí es posible. Se debe cumplir que la clase del objeto retornado por la redefinición debe ser subclase de la clase del objeto retornado por el método redefinido.
>>> PREGUNTAR

> ¿Cuándo se usa la sentencia import javax.swing.JOptionPane;? ¿Podríamos omitir este “import”?
>> La sentencia import javax.swing.JOptionPane; se usa cuando deseamos crear instancias de la clase JOptionPane, como en:
>> ```JOptionPane obj=new JOptionPane();``` Sí se puede omitir, pero cada vez que deseemos crear una instancia de esa clase debemos usar la especificación completa como en:
>> ```javax.swing.JOptionPane obj=new javax.swing.JOptionPane();```




>  ¿Qué diferencia existe entre el operador == y el uso del método equals(…)?
> Un estudiante revisa una clase y no encuentra en ella la implementación del método equals(…) ¿por qué
> no se produce error al invocarlo sobre una instancia de esa clase?
>> Diferencia entre == y método equals(…): El primero compara dos referencias, será verdadero si dos
>> nombres (o referencias a objetos) se refieren al mismo objeto. El método equals(…) compara dos objetos por igualdad.
>> No se produce error pues todo objeto hereda de la clase Object aunque no lo explicite. La clase Object
>> implementa el método equals(…) por ello no hay error al invocarlo.