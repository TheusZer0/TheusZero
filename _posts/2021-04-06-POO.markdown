---
layout: post
title: "POO"
subtitle: 'POO'
date: 2021-04-02 12:00:00
author: "TheusZero"
header-img: "images/post/PythonAutoayuda/solarized-wallpaper-python.png"
catalog: true
comments: true
tags:
    - Programacion
    - Python
    - USM
    - Tareas
    - Java
    - C++
---

## Programacion en java codigo

[Curso Java Intermedio - La Geekipedia De Ernesto](https://www.youtube.com/watch?v=TjrPp48_ms0&list=PLyvsggKtwbLXEZjb8HrNTbWesTKIfpNak)

[Curso Java - Programacion ATS](https://www.youtube.com/watch?v=2ZXiuh0rg3M&list=PLWtYZ2ejMVJkjOuTCzIk61j7XKfpIR74K)

#### arrays Unidimensionales
> ![](/TheusZero/images/post/POO/6.png)
> ![](/TheusZero/images/post/POO/7.png)
> ![](/TheusZero/images/post/POO/8.png)

#### arrays bidimensionales o de muchas dimensiones
> ![](/TheusZero/images/post/POO/10.png)
> ![](/TheusZero/images/post/POO/11.png)
> ![](/TheusZero/images/post/POO/12.png)

#### for each
> ![](/TheusZero/images/post/POO/9.png)

## Clases, objetos y comportamiento

> ![](/TheusZero/images/post/POO/13.png)

> Clases, forma generalizada (idea) para hablar de objetos ya que estas definen las caracterizticas generales de una clase objeto.
>> objeto Patricio, clase Persona

Estas clases tienen **atributos** que son generales (RUT, EDAD, etc) y tambien tenemos comportamientos llamados **metodos**, (caminar, comer, respirar, etc).
Estos estaran definidos desde la clase.

> por lo que, las clases son un conjunto de objetos con caracteristicas similares
> ![](/TheusZero/images/post/POO/14.png)

> Clase: es la definición de las características comunes a un conjunto de objetos. Las característica comunes son los atributos a considerar y el comportamiento de esos objetos.

> Objeto: en POO un objeto es la representación en un programa de un objeto real. Esta representación define un nombre, un estado y un comportamiento para el objeto. Un objeto es una instancia de una Clase.

> Atributo: es una un dato que permite almacenar parte del estado de un objeto. El conjunto de atributos de un objeto almacenan su estado.

> Constructor: Código que define el valor inicial de un objeto al ser creado.

#### creacion de clases y objetos

> ![](/TheusZero/images/post/POO/15.png)

> ![](/TheusZero/images/post/POO/16.png)

> ![](/TheusZero/images/post/POO/17.png)

> ![](/TheusZero/images/post/POO/18.png)

> ![](/TheusZero/images/post/POO/19.png)

> ![](/TheusZero/images/post/POO/20.png)


#### Constructores

> ![](/TheusZero/images/post/POO/21.png)
>> O bien tambien puede quedar: 
>> ![](/TheusZero/images/post/POO/22.png)
> ![](/TheusZero/images/post/POO/23.png)

#### Miembros estáticos de una clase

> si se antepone static, la variable pasa a ser para toda la clase, es decir, que si hacemos un cambio, este repercute y cambia todas las variables, por ejemplo
>> ![](/TheusZero/images/post/POO/26.png)

> ademas para la creacion de clase, esto pasa:
>> ![](/TheusZero/images/post/POO/27.png)

#### metodos getter/setter

> ![](/TheusZero/images/post/POO/24.png)

#### Jerarquias de Clases: Herencia

> la clase estudiante y profesor heredan de la clase persona atributos, por lo que hay una jerarquia que define a persona como un general del cual heredan atributos otras clases
> ![](/TheusZero/images/post/POO/2.png)
> ![](/TheusZero/images/post/POO/3.png)
> ![](/TheusZero/images/post/POO/4.png)
> ![](/TheusZero/images/post/POO/5.png)

#### clases y metodos abstractos:

> Clase abstracta
>> Se utilizan solo como super clases (clases padres)
>
>> No se pueden instanciar objetos, no puedes crear objetos
>
>> Sirve para proporcionar una clase padre apropiada a partir de la cual heredan otras clases, siendo estas otras clases hijas las que extenderan el funcionamiento de los metodos, es decir, que seran quienes expliquen el funcionamiento en base a codigo. La clase Padre solo dice que el metodo existe, pero no como es que sera llevado a cabo.
>
>> ![](/TheusZero/images/post/POO/30.png)
>> ![](/TheusZero/images/post/POO/31.png)
>> ![](/TheusZero/images/post/POO/32.png)
>> ![](/TheusZero/images/post/POO/33.png)
>> ![](/TheusZero/images/post/POO/34.png)
>> ![](/TheusZero/images/post/POO/35.png)
>> ![](/TheusZero/images/post/POO/36.png)

#### Interfaces

![](/TheusZero/images/post/POO/39.png)

> colecciones de metodos abstractos y propiedades constantes, en que se especifican que se hara, es decir, que definen metodos pero sin cuerpo, dictan que se hara, pero no como se implementara.
> Las clases hijas deeben definir el comportamiento de todo metodo abstracto
>> ![](/TheusZero/images/post/POO/37.png)
>> ![](/TheusZero/images/post/POO/38.png)


> Clase abstracta vs Intefaz
>> la principal diferencia entre una clase abstracta y una normal, es que la clase abstracta tiene almenos (por obligacion) un metodo abstracto
>>> metodo abstracto = no posee cuerpo, es un metodo que solo define que existe, pero que no tiene que cuerpo, es decir, que no explica que se hara.
> Como java no permite la herencia multiple, son las interfaces las que se usan, siendo estas contratos donde se estipula que se debe hacer en cada tarea y seran las clases hijas las encargadas de realizar estas tareas. 

#### metodo copiar, Copia baja y profunda

**Copia baja** es aquella donde la **copia de un objeto** se efectúa **copiando el valor de sus atributos** y **cuando
un atributo es un objeto sólo se copia su referencia**, como consecuencia **en copia baja los atributos
objetos son compartidos entre el objeto original copiado y su destino**.

Copia profunda es aquella donde la copia de un objeto sólo copia los atributos escalares (no objetos) y
los objetos inmutables (que no pueden cambiar) y para aquellos objeto mutables se generan copias
profundas de cada uno. De este modo se genera una nueva versión del objeto que no comparte objetos
mutables con el objeto copiado.

El método clone() implementa copia baja

![](/TheusZero/images/post/POO/41.png)

>> Copia profunda: todas las variables del objeto copiado contienen el mismo valor que el objeto original, excepto aquellas variables que se refieren a otros objetos. Las variables que se refieren a otros objetos apuntarán a los objetos nuevos copiados y ya no serán los objetos referenciados originales. En otras palabrasCopia profunda copia los objetos a los que hace referencia el objeto a copiar
>
>> Copia superficial:Todas las variables del objeto copiado tienen el mismo valor que el objeto original, mientras que todas las referencias a otros objetos todavía apuntan al objeto original. En otras palabrasLa copia superficial solo copia el objeto en cuestión, no los objetos a los que hace referencia.

El método clone() existe con acceso protegido en la clase Object.

Para invocarlo sobre un objeto se requiere que la clase del
objeto implemente la interfaz Cloneable, lo cual significa que
debemos redefinir el método clone.

Para generar un clone correcto, debemos hacerlo invocando
el método clone de la clase Object.

El método clone de Object crea y retorna un objeto con igual
estructura al objeto llamado e inicializa todos sus campos
con el mismo contenido de los campos del objeto llamado.
Los contenidos de cada campo no son clonados (hasta aquí
se le llama copia baja), luego para una copia completa
(profunda) se debe llamar el método clone de cada atributo.

#### Poliformismo

El uso de abstracciones e interfaces son formas de poliformismo. (clase padre define un metodo y las hijas lo expanden para su uso especifico).

Polimorfismo es un concepto donde un
mismo nombre puede referirse a objetos de clases
diferentes que están relacionadas por una clase base
común.

Es una relacion de tipo herencia, donde un objeto de la superclase (clase padre) puede almacenar un objeto de cualquiera de las subclases (clases hijas)

Esto significa que la clase padre o superclase es compatible con los tipos que derivan de ella pero no al reves.

![](/TheusZero/images/post/POO/43.png)
![](/TheusZero/images/post/POO/44.png)
![](/TheusZero/images/post/POO/45.png)

#### ligadura

La ligadura dinámica se encarga de ligar o relacionar la llamada a un método con el cuerpo del método que se ejecuta finalmente.

>Ligadura estática:
>> Consiste en realizar el proceso de ligadura en tiempo de compilación según el tipo declarado del objeto al que se manda el mensaje.
> 
>> La utilizan (en Java) los métodos de clase y los métodos de instancia que son privados o final (ya que estos últimos no pueden ser sobrescritos).

>Ligadura dinámica:
>>Consiste en realizar el proceso de ligadura en tiempo de ejecución siendo la forma dinámica del objeto la que determina la versión del método a ejecutar.
>
>>Se utiliza en todos los métodos de instancia de Java que no son privados ni final.

> Funcionamiento de la Ligadura Dinámica:
>> Resolución de conflictos entre Superclases y Subclases:
>
>> Cuando existe un conflicto entre un método de una superclase y un método de la subclase, el comportamiento correcto es que el método de la subclase sobrescriba al de la superclase.
>
>> Si estamos llamando a un método de la subclase desde una variable que ha sido declarada del tipo de la superclase. ¿Cómo se consigue que funcione correctamente?
>
> Ligadura Dinámica:
>> Significa que la forma dinámica del objeto determina la versión de la operación que se aplicará.
>
>> Esta capacidad de las operaciones para adaptarse automáticamente a los objetos a los cuales se aplican es una de las propiedades más importantes de la orientación a objetos.
>
> Características de la Ligadura Dinámica:
>> Puede variar de un lenguaje a otro, pero básicamente presentan unas características comunes. Los métodos que necesitan ligadura dinámica:
>
>> Deben presentar ligadura dinámica solo aquellos que pueden ser redefinidos.
>
>> Por ejemplo, en Java, los métodos de clase y los métodos de instancia privados y/o finales no presentan ligadura dinámica.
>
>> En Java, si no se especifica nada se entenderá que el método puede ser redefinido y por tanto debe presentar ligadura dinámica

## Programacion JavaFX

programacion de graficas con JavaFX.

#### Gráficas y Eventos

> Oyente de acción (ActionListener)
>> metodo que agrega un oyente de accion, es decir, que cuando suceda algo entonces accionara una respuesta, se usa para los botones de JavaFX
> 

## Preguntas Certamenes

> Explique por qué se recomienda reemplazar los “tabs” por espacios para indentar código fuente.
>> Así la indentación se visualiza de igual forma en distintos editores y sus versiones impresas. El
>> tamaño de cada tab es definido por el entorno, luego lo que se ve indentado en uno puede no
>> estarlo en otro.

> Nombre y explique tres características que comparten los lenguajes orientados a objetos.
>> Herencia: la posibilidad de definir una clase o tipo de objeto a partir de la definición de otra.
>
>> Subtipo: la posibilidad de usar instancias de clases derivadas donde se espera una instancia de la
>> clase base.
>
>> Ligado dinámico: el código invocado ante un llamado es definido en tiempo de ejecución
>> permitiendo así que el resultado dependa del objeto específico que recibe el llamado. En conjunto
>> con subtipo, permite generar códigos reusables

> La clase Timer está definida en java.util.Timer y en javax.swing.Timer. ¿Qué definición de import debe
> hacer en su código para usar Timer del paquete java.util?
>> import java.util.Timer;
> ¿Cómo lo hace si además de esta clase, en su programa usted requiere crear instancias de Timer el paquete javax.swing?
>> Como antes al inicio uso:
>> import java.util.Timer;
>> Luego cada vez que desee usar una instancia de Timer de javax.swing, uso la versión completa
>> para la clase, esto es:
>> javaxswing.Timer miTiner; /* así cada vez que requiero referirme a instancias de esta clase*/

> Alguien dice: “Sea emp una instancia de Empleado, al asignar emp=null; en todos los casos el espacio de
> memoria referenciado por emp será recolectado por el recolector de basura de java. ¿Está de cuerdo? Explique.
>> No, debido a que podemos tener más de un nombre para un objeto; es decir, pude haber más de
>> una referencia apuntando a un objeto. El recolector de basura sólo recupera el espacio de memoria
>> cuando no hay referencias a ese espacio

> ![](/TheusZero/images/post/POO/25.png)

> Alguien dice: “Si en un archivo tenemos definidas dos clases A y B, sólo una de ellas puede contener el
> método public static void main (String argv[]) {….. }” ¿Está usted de acuerdo? Justifique.
>> No estoy de acuerdo. El método main puede estar en más de una clase. Aquella que use al correr el
>> programa definirá qué método main es usado.

> Alguien dice: Si B hereda de A y hemos declarado: ```B b;``` entonces será un error de compilación si en alguna parte del programa hacemos: ```A a= (A) b;``` ¿Está usted de acuerdo? Justifique.
>>No estoy de acuerdo, pues eso es perfectamente posible. b hereda de A, luego por subtipo puede
>>tomar el lugar donde se espera una instancia de A. Incluso es válido poner: ```B b2 = (B) a;``` debido a que a bien podría ser referencia a instancias de B, en cuyo caso el casteo es posible
>>> PREGUNTAR, que pasaria si B tiene variables que A no tiene? donde quedan?

> ![](/TheusZero/images/post/POO/28.png)
> ```AQUI IRA MI CODIGO```

>> Ejercicio Vectores
> ![](/TheusZero/images/post/POO/29.png)

> La clase C hereda de B, y B hereda de A. A posee un método protegido getPeso(), el cual no es redefinido
> por B. ¿Es posible redefinir este método en C?
>> Sí. Los métodos protegidos dan visibilidad a las clases derivadas.
> Si su respuesta es afirmativa, ¿cómo podemos llamar la implementación de A de getPeso() desde algún
>método de C?
>> La invocación la haríamos con super.getPeso();
>> Esto funciona pues la versión de getPeso() visible en la clase B es justamente aquella definida en A

> Al redefinir un método en una subclase, ¿es posible retornar un objeto de distinta clase al retornado en el método de la super clase? Explique.
>> Sí es posible. Se debe cumplir que la clase del objeto retornado por la redefinición debe ser subclase de la clase del objeto retornado por el método redefinido.
>>> PREGUNTAR

> ¿Cuándo se usa la sentencia import javax.swing.JOptionPane;? ¿Podríamos omitir este “import”?
>> La sentencia import javax.swing.JOptionPane; se usa cuando deseamos crear instancias de la clase JOptionPane, como en:
>> ```JOptionPane obj=new JOptionPane();``` Sí se puede omitir, pero cada vez que deseemos crear una instancia de esa clase debemos usar la especificación completa como en:
>> ```javax.swing.JOptionPane obj=new javax.swing.JOptionPane();```

> Alguien dice: un cuadrado es un rectángulo de lados iguales. Al ver la forma es-un,
> piensa en herencia. Dé dos razones por las que no es bueno definir la clase Cuadrado como heredando de Rectángulo.
>> Al hacerlo estaríamos usando más memoria de la necesaria para almacenar cuadrados.
>
>> Habría problemas al aplicar el principio de sustitución. Si un método espera un rectángulo para crear la portada de un libro, el método no podrá definir un alto distinto de un ancho si el objeto fuera instancia de cuadrado.

> La expresión “hola”==”hola”, ¿es verdadera o falsa? Explique.
>> Es verdadera. Los strings son objetos en Java, pero por tratarse de strings literales, es
>> secuencia de caracteres entre “”, éstos quedan internos en la clase String y el
>> compilador asocia una única referencia a iguales contenidos

> Si las técnicas de orientación a objeto pueden dar solución a los mismos problemas que
> los lenguajes no orientados a objetos, ¿Dé dos razones para su uso común en los lenguajes actuales?
>> La orientación a objeto facilita la reutilización de código.
> 
>> La orientación a objeto facilita el trabajo en equipo

> Juan instaló el JDK de java, Pedro instaló JRE. Mencione dos cosas que puede hacer Juan pero no Pedro.
>> Juan puede compilar programas con javac.
> 
>> Juan puede extraer la documentación de un programa con javadoc

>> Pregunta Importante
> La clase B es derivada de A. En B redefinimos el método público getEdad() de A.
> ¿Cómo podemos invocar getEdad() implementado por A desde otro método en B?
> ¿Cómo desde este método en B podemos invocar getEdad() implementado en B?
>> Para invocar implementación de A, en el método de B pongo: ```super.getEdad();``` // con esto invocamos la implementación de A.
>
>> Para invocar implementación de B, pongo: ```getEdad();``` // Así invocamos la implementación en B desde un método de B.

> ¿Es posible impedir que un método sea redefinido en una clase derivada? Justifique.
> Sí es posible, basta poner agregar el calificador final al método, como en: ```class A { public final int getEdad() {....} ....}```

> a) Para un juego se le pide crear dados de N caras. Estos dados pueden tomar valores dentro del
> conjunto {1,2,3,..., N}. Cree la clase Dado. Ésta permite definir el número de caras en su
> constructor. Si no se señala, se asume 6 caras. Estos dados deben permitir ser lanzados y en
> cualquier momento se puede consultar el valor del último lanzamiento del dado.
> b) Desarrolle Juego, una aplicación Java que usa la clase definida en a) y muestra una interfaz
> gráfica con un botón, el cual lanza un dado al ser presionado, y un área para mostrar el resultado
> del lanzamiento. El número de caras es ingresado por consola vía un argumento en la línea de
> ejecución de esta aplicación.
> c) Señale qué cambio debe hacer a su clase Dado para implementar la interfaz Comparable
> basado en el último lanzamiento de los dados.

> ¿La Programación Orientada a Objeto es un tipo de programación Imperativa o Declarativa? Explique.
>> La Programación Orientada a Objetos (POO) es Imperativa. En la programación Imperativa el
>> programa señala cómo se debe llevar la computación. Éste es el caso de la POO.
>> (Nota: En la programación declarativa se indica qué se debe hacer y las condiciones en las cuales se
>> hace, pero no el cómo se debe hacer)

> Defina con sus palabras los siguientes términos: instancia, clase heredada, principio de sustitución.
>> Instancia es un objeto o ente específico que cumple con la descripción hecha en una clase.
>> Clase heredada: es una clase definida a partir de otra más general llamada clase base, padre o
>> superclase. Una clase heredada reutiliza el código y extiende la clase base haciéndola más específica.
>> Principio de sustitución: es la propiedad de los objetos de poder tomar el lugar donde se esperaba uno de
>> categoría más general. Se da entre instancias de clases derivadas donde se espera una de la base o de
>> jerarquía superior. También se da entre instancias de una clases que toman el lugar donde se espera un
>> objeto que cumpla una interfaz

> ¿Qué hace posible que un mismo byte-code pueda correr en máquinas de distintas arquitecturas y distintos sistemas operativos?
>> Esto se logra por la existencia de una Máquina Virtual Java (JVM) para cada par (arquitectura, sistema operativo).

> Mencione dos usos de la palabra reservada “final”.
>> “final” lo usamos para identificar que un atributo no puede cambiar su valor una vez asignado en su constructor. “final” también lo usamos para indicar que un método no puede ser redefinido en clases derivadas

> ¿Por qué se dice que la relación es-un entre clases es una condición necesaria pero no suficiente para
> identificar relación de herencia entre clases? ¿Qué condición adicional se debe cumplir para que identificar herencia?
>> Es una condición necesaria pues la relación de herencia sólo se da cuando existe la relación es-un entre
>> una instancia de la clase heredada y una instancia de la clase base. No es suficiente pues existen casos
>> de relación es-un pero donde no hay herencia. Un ejemplo de esto es: un cuadrado es un rectángulo de
>> lados iguales. Existe relación es-un pero no herencia.
>> La condición adicional es cumplir el principio de sustitución. En el ejemplo previo el comportamiento de
>> un rectángulo nos permite ensancharlo hasta que su ancho sea, por ejemplo, el doble de su alto. Si en su
>> lugar usáramos un cuadrado, este comportamiento no es posible.

> Mencione dos semejanzas entre clases abstractas e interfaces en Java. Mencione una diferencia entre ambas.
>> Semejanzas: No podemos crear instancias de clases abstractas ni de interfaces. Las clases abstractas y
>> las interfaces poseen métodos no implementados.
> 
>> Diferencia: Una clase pude derivar de sólo una clase abstracta, pero puede implementar múltiples
>> interfaces.

>> ¿Qué imprime el programa Test?
> ![](/TheusZero/images/post/POO/40.png)
>> Preguntar por el ultimo ```A aa = (A)a; aa.quienSoy();```

> Reescriba el programa adjunto para crear una versión que no haga uso de clases internas ni clases anónimas
> ```java
>     public class CreaBotones {
>      public static void main(String[] args) {
>      CreaBotonesFrame frame = new CreaBotonesFrame();
>      frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
>      frame.setVisible(true);
>       }
>     }
>     class CreaBotonesFrame extends JFrame {
>      public CreaBotonesFrame() {
>      setSize(250, 150);
>      CreaBotonesPanel panel = new CreaBotonesPanel();
>      Container contentPane = getContentPane();
>      contentPane.add(sp);
>       }
>     }
>     class CreaBotonesPanel extends JPanel {
>      public CreaBotonesPanel() {
>      creaBoton();
>       }
>      private void creaBoton() {
>      JButton boton = new JButton("Crea Boton");
>      boton.addActionListener( new ActionListener (){
>      public void actionPerformed(ActionEvent event) {
>      creaBoton();
>       };
>      });
>      add(boton);
>      validate();
>       }
>     }
> ```
>> ![](/TheusZero/images/post/POO/42.png)

> ¿Qué pasos involucra el diseño e implementación orientados a objetos?
>> Identificar los objetos relevantes del problema a resolver. Cada categoría de objetos da origen a una clase.
>> Identificar la relación entre las clases.
>> Identificar los atributos y comportamientos o servicios que éstas deben cumplir.
>> Implementar cada uno de los comportamientos o servicios, eventualmente haciendo uso de los servicios ofrecidos
>> por otras clases de objetos.

> Además de mantener el nombre del método y sus parámetros ¿En qué otra(s) cosa(s) debemos poner atención al redefinir un método presente en una clase base?
>> Debemos fijarnos que si retornamos un objeto, éste debe ser instancia de la misma clase del método a redefinir o bien instancia de una clase derivada de ésta.
> 
>> También debemos fijarnos en mantener las excepciones, si éstas no son lanzadas, en la redefinición no podemos
>> lanzar excepciones.

> ¿Es posible tener un programa con implementaciones para el método main en dos clases? Explique por qué no o cómo se usaría tal cosa.
>> Sí es posible.
>
>> Cómo se usaría: Se crean métodos main en dos clases distintas, luego al compliar se generarán los dos .class
>> correspondientes. Para correr cada versión de main, usamos el nombre de la clase correspondiente como
>> parámetro de la máquina virtual Java.

> ¿Qué debemos hacer para dar sentido a la salida: System.out.print(persona); cuando persona es un objeto?
>> Basta redefinir el método toString en la clase correspondiente a persona.

> Como atributo de una clase se tiene static final double valorDolar, cuyo valor es leído desde teclado ¿cómo se debe
> programar tal inicialización? (puede usar pseudo código para la lectura de teclado).
> En la clase donde esta constante está incluir una inicialización estática, del tipo:
> ```java
> static final double valorDolar;
> static {
> Scanner s = new Scanner(System.in);
> valorDolar = s.nextDouble();
> }
> ```

> Al diseñar una solución de software ¿qué lo hace decidir por crear una clase abstracta en lugar de una clase en
> propiedad? ¿qué lo hace optar por crear una interfaz?
>> Creamos una clase abstracta cuando no es posible dar una implementación a alguno de los métodos de la clase.
>> Optamos por una interfaz cuando no se cuenta con lo necesario para implementar cada uno de los métodos no
>> estáticos. También optamos por una interfaz cuando las clases que la implementan ya derivan de alguna otra clase.

> Un segmento de código Java muestra:
> ```
> String texto = “UTFSM”;
> JLabel label = new JLabel(texto);
> …..….. /*Aquí se muestra el label en pantalla y luego*/
> texto = “USM”; repaint();
> ```
> ¿Al actualizar texto en la línea previa, cambia lo desplegado por label en pantalla? Justifique.
>> No cambia. El string pasado en el constructor de JLabel no cambia por la asignación de un nuevo string a texto.
>> En java se pasan referencias. Además los string son inmutables, cualquier invocación de método sobre texto, no
>> cambiará el string originalmente asignado

> ¿Qué crítica se hizo a los lenguajes tradicionales no orientados a objetos que condujo a incorporar excepciones en los
> lenguajes Orientados a Objetos como Java y C++?
>> Que mezclaban el tratamiento de errores (casos poco frecuentes) con la lógica principal del código (objetivo
>> principal del código), dificultando su claridad y mantención futura.

> ¿Qué significa polimorfismo? ¿Cuáles son los distintos tipos de polimorfismo?
> Polimorfismo es la cualidad de usar un mismo nombre para referirse a cosas similares.
>> Algunos tipos de polimorfismo son:
> 
>> a) Cuando vía herencia un mismo nombre, instancia de la clase hoja, puede tomar también el lugar
>> de una instancia de la clase base.
> 
>> b) Hay polimorfismo cuando varias clases implementan una interfaz. Luego podemos crear código
>> genérico en el sentido que depende sólo de los métodos de la Interfaz. Este código genérico puede
>> ser usado con objetos de distintas clases que implementan la interfaz.
> 
>> c) Hay polimorfismo cuando en una clase base definimos métodos abstractos que luego las clases
>> derivadas definen. Este es un caso similar al b).
> 
>> d) Algunos autores también consideran polimorfismo cuando un mismo método puede ser
>> invocado usando diferentes tipos de datos como parámetros (sobrecarga de métodos), pero otros no
>> lo consideran así.
> 
>> Con un par de casos es OK.

> Dé ejemplos simples de dos distintos tipos de polimorfismo
> 
>> Primer ejemplo: Polimorfismo cuando hay herencia.
>> ```java
>> class Persona {
>> ….
>> }
>> class Empleado extends Persona {
>> …
>> }
>> ```
>
>> ```java
>> Segundo caso: Polimorfismo cuando tenemos interfaces.
>> Class Empleado implements Comparable{
>> ….
>> }
>> Empleado[] funcionarios = new Empleado[50];
>> /* Crear los empleados */
>> Array.sort(funcionarios);
>> ```

> ¿Qué es ligado dinámico? Indique un beneficio y un perjuicio de usar esta técnica.
>> Ligado dinámico es la definición en tiempo de ejecución del código a ejecutar ante una
>> invocación de un método.
> 
>> Beneficio: permite crear código reutilizable.
> 
>> Perjuicio: El ligado dinámico es más lento de ejecutar que el estático definido en tiempo de
>> compilación.

> ¿Para qué sirve la clase Class? De un ejemplo simple de su uso.
>> La clase Class permite consultar información sobre la clase de un objeto en tiempo de
>> ejecución.
>> ```java
>> class Source {
>> ..
>> }
>> System.out.println((new Source()).getClass.getName());
>> ```
>> Retorna Source.

> ¿En qué contexto en Java se usan los listeners? Haga un diagrama de secuencia para mostrar los pasos generales para su uso.
>> Los listener se usan para registrar código a ejecutar ante la ocurrencia de un evento.
>> ![](/TheusZero/images/post/POO/46.png)

> ¿Describa por qué motivo se extiende JFrame en el contexto de los GUIs de Java? ¿Qué parte juegan los listeners en esta implementación?
>> Se extiende JFrame porque ésta es una componente gráfica de nivel superior; es decir, puede
>> existir por sí sola en un escritorio.
>> Los listener llevan a cabo la ejecución de la lógica del programa cada vez que un evento ocurre.
>> Otra respuesta es: los listener permiten implementar la programación conducida por eventos.

> ¿Qué beneficios otorgan las excepciones? ¿Cuántos tipos hay y cuales son?
>> El beneficio de las excepciones es separar las condiciones de error de la lógica principal de un
>> segmento de código (o método).
>> Hay de dos tipos, aquellas generadas por el lenguaje; por ejemplo, cuando se accede a una
>> referencia null. El otro tipo son las incluidas por el programador.

> ¿Las excepciones siempre tienen que ser capturadas? ¿Por qué? ¿En qué caso no es necesario
> capturar una excepción? ¿En qué caso no es posible relanzar una excepción?
>> No, por que una excepción también puede ser relanzada.
>> No es necesario capturar excepciones cuando son generadas por el lenguaje (división por cero, etc).
>> No es posible relanzar una excepción cuando estamos redefiniendo un método que no lo hace.

> Para este código utilice instance of y Casteo para lograr que el arreglo staff almacene Managers y
> Employees. También debe poder almacenar valores de bonus en staff de tipo Manager, debe poder
> imprimir toda la información de staff (incluyendo el bono de los Managers). Debe modificar las clases
> y métodos si es necesario.
```java
import java.util.*;
public class Main {
 public static void main(String[] args) {
 Employee[] staff = new Employee[3];
 // fill the staff array with Manager and Employee objects
 staff[0] =
 staff[1] =
 staff[2] =
 // using cast set bonus information for Manager staff to 9999
 for (int i = 0; i < staff.length; i++) {
 ...
 }
 // print out ALL information about all staff including Managers and Employees
 for (int i = 0; i < staff.length; i++) {
 ...
 }
 }
}
class Employee {
 public Employee(String n, double s,
 int year, int month, int day) {
 name = n;
 salary = s;
 GregorianCalendar calendar = new GregorianCalendar(year, month - 1, day);
 // GregorianCalendar uses 0 for January
 hireDay = calendar.getTime();
 }
 ...
}
class Manager extends Employee {
 public Manager(String n, double s,
 int year, int month, int day) {
 super(n, s, year, month, day);
 bonus = 0;
  }
 ...
 private double bonus;
}
```
> Solucion
```java
import java.util.*;
/**
 * @author tomas agustin
 */
public class Main {
 public static void main(String[] args) {
 Employee[] staff = new Employee[3];
 // fill the staff array with Manager and Employee objects
 staff[0] = new Manager("Carl Cracker", 80000, 1987, 12, 15); 4 pts
 staff[1] = new Employee("Harry Hacker", 50000, 1989, 10, 1);
 staff[2] = new Employee("Tommy Tester", 40000, 1990, 3, 15);
 // using cast set bonus information for Manager staff to 9999
 for (int i = 0; i < staff.length; i++) {
 if (staff[i] instanceof Manager) { 5 pts
 Manager m = (Manager) staff[i];
 m.setBonus(9999);
 }
 }
 // print out information about all staff
 for (int i = 0; i < staff.length; i++) {
 Employee e = staff[i]; 8 pts.
 System.out.print("name=" + e.getName() + ",salary=" + e.getSalary());
 if (e instanceof Manager) {
 Manager m = (Manager) e;
 System.out.print(",bonus=" + m.getBonus());
 }
 System.out.println();
 }
 }
 }
}
class Employee {
 public Employee(String n, double s,
 int year, int month, int day) {
 name = n;
 salary = s;
 GregorianCalendar calendar = new GregorianCalendar(year, month - 1, day);
 // GregorianCalendar uses 0 for January
 hireDay = calendar.getTime();
 }
 public String getName() { 4 pts resto de clase
 return name;
 }
 public double getSalary() {
 return salary;
 }
 public Date getHireDay() {
 return hireDay;
 }
 public void raiseSalary(double byPercent) {
 double raise = salary * byPercent / 100;
 salary += raise;
 }
 private String name;
 private double salary;
 private Date hireDay;
}
class Manager extends Employee {
 public Manager(String n, double s,
 int year, int month, int day) {
 super(n, s, year, month, day);
 bonus = 0;
 }
 public double getSalary() { 4 pts resto de clase
 double baseSalary = super.getSalary();
 return baseSalary + bonus;
 }
 public void setBonus(double b) {
 bonus = b;
 }
 public double getBonus() {
 return bonus;
 }
 private double bonus;
}
```







>  ¿Qué diferencia existe entre el operador == y el uso del método equals(…)?
> Un estudiante revisa una clase y no encuentra en ella la implementación del método equals(…) ¿por qué
> no se produce error al invocarlo sobre una instancia de esa clase?
>> Diferencia entre == y método equals(…): El primero compara dos referencias, será verdadero si dos
>> nombres (o referencias a objetos) se refieren al mismo objeto. El método equals(…) compara dos objetos por igualdad.
>> No se produce error pues todo objeto hereda de la clase Object aunque no lo explicite. La clase Object
>> implementa el método equals(…) por ello no hay error al invocarlo.